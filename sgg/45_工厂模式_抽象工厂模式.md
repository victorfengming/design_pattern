
 
 
 # 抽象工厂模式
 
 ### 基本介绍
 
 1. 抽象工厂模式: 定义了一个Interface用于创建相关或有依赖关系的对象,而无需指明具体的类
 
 2. 抽象工厂模式可以将 __简单工厂模式__ 和 __工厂方法模式__ 进行整合.
 
 3. 从设计层面看,抽象工厂模式就是对简单工厂模式的改进(或者成为进一步的抽象)
 
 4. 将工厂抽象成2层,AbsFactory(抽象工厂)和具体实现的子工厂类. 程序员可以根据创建对象类型使用对应的工厂子类. 这样将单个的简单工厂编程了 __工厂簇__,
 更利于代码的维护和扩展.
 
 ### 说白了
 
 我们可以把这个要创建对象实例的方法做成一个抽象方法,放到一个接口里面,然后让下面的一个工厂子类去实现,然后我们需要哪个工厂就把他们聚合到我们的使用类/客户端 即可
 
 这样一个简单的工厂类就变成了一堆儿工厂类,这样就利于我们 代码的扩展和修改
 
 ### 看一个类图
 
 ![](./img/QQ截图20210204092612.png)
 
 如果要扩展, 可以这样加一个类
 
 ![](./img/QQ截图20210204092613.png)
 
 
 ### 代码演示
 #### pizza
BJCheesePizza

```java
public class BJCheesePizza extends Pizza {

    @Override
    public void prepare() {
        setName("北京的奶酪披萨");
        System.out.println("给北京的奶酪披萨准备原材料!");
    }
}
```
BJPepperPizza

```java
public class BJPepperPizza extends Pizza {
    
    @Override
    public void prepare() {
        setName("北京的胡椒披萨");
        System.out.println("北京的胡椒披萨准备原材料!");
    }
}
```

LDCheesePizza
```java
public class LDCheesePizza extends Pizza {
    @Override
    public void prepare() {
        setName("伦敦奶酪披萨!");
        System.out.println("给伦敦奶酪披萨准备原材料");
    }
}

```

LDPepperPizza

```java
public class LDPepperPizza extends Pizza {
    @Override
    public void prepare() {
        setName("给伦敦的胡椒披萨");
        System.out.println("给伦敦的胡椒披萨准备原材料!");
    }
}

```

Pizza

```java
public abstract class Pizza {

    protected String name;  // 披萨名字
    // 准备原材料,不同的pizza是不一样的
    // ,因此我们做成一个抽象方法
    public abstract void prepare();

    // 烘烤
    public void bake() {
        System.out.println(name+"baking;");
    }

    // 切片
    public void cut() {
        System.out.println(name+"cutting;");
    }

    //打包
    public void box() {
        System.out.println(name+"boxting;");
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

 #### order
AbsFactory


```java
// 一个抽象工厂模式的抽象层(接口)
public interface AbsFactory {
    // 让下面的工厂子类来具体实现
    public Pizza createPizza(String orderType);
}
```
BJFactory


```java
// 这是一个工厂子类
public class BJFactory implements AbsFactory{
    @Override
    public Pizza createPizza(String orderType) {
        System.out.println("使用到的是抽象农场模式i");
        Pizza pizza = null;
        if (orderType.equals("cheese")) {
            pizza = new BJCheesePizza();
        } else if (orderType.equals("pepper")) {
            pizza = new BJPepperPizza();
        } else {

        }
        return pizza;
    }
}

```
LDFactory


```java

public class LDFactory implements AbsFactory{
    @Override
    public Pizza createPizza(String orderType) {
        Pizza pizza = null;
        if (orderType.equals("cheese")) {
            pizza = new LDCheesePizza();
        } else if (orderType.equals("pepper")) {
            pizza = new LDPepperPizza();
        } else {

        }
        return pizza;
    }
}

```
OrderPizza


```java

public class OrderPizza {
    // 聚合
    AbsFactory factory;

    // 构造器
    public OrderPizza(AbsFactory factory) {
        setFactory(factory);
    }

    private void setFactory(AbsFactory factory) {
        //
        Pizza pizza = null;
        String orderType = "";  // 用户输入
        this.factory = factory;

        do {
            orderType = getType();
            // factory 可能是北京的工厂子类,也可能是伦敦的工厂子类
            pizza = factory.createPizza(orderType);
            if (pizza != null) {
                pizza.prepare();
                pizza.bake();
                pizza.cut();
                pizza.box();
            } else {
                System.out.println("订购失败!");
                break;
            }

        } while (true);

    }


    // 写一个方法,可以获取客户希望订购的披萨种类
    private String getType() {
        BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("input pizza type:");
        String str = null;
        try {
            str = strin.readLine();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return str;
    }
}

```
PizzaStore
 
 

```java
package com.atguigu.factory.absfactory.order;

/**
 * ClassName: PizzaStore <br/>
 * Description: PizzaStore <br/>
 * Date: 2021-02-04 9:45 <br/>
 * <br/>
 *
 * @author victor
 * @version 产品版本信息 2021年02月04日9:45分 victor(victorfm@163.com) 新建<br/>
 * <p>
 * 修改记录
 * @email victorfm@163.com
 * @project java_mode
 * @package com.atguigu.factory.absfactory.order
 */
public class PizzaStore {
    public static void main(String[] args) {
        System.out.println();
        new OrderPizza(new BJFactory());
        // 运行
        /*
        input pizza type:
        cheese
        使用到的是抽象农场模式i
        给北京的奶酪披萨准备原材料!
        北京的奶酪披萨baking;
        北京的奶酪披萨cutting;
        北京的奶酪披萨boxting;
        * */
    }
}

```


### 总结

如果你的产品种类很多,那么,你用这个抽象工厂模式更加的灵活的哦

如果你就那么几种产品,嗯,你就老老实实的用简单的工厂模式就够了

要活学活用,不能像玉鼎真人一样,只会死背书就连简单的爬云都不会