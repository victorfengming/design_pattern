
# 静态内部类

 静态内部类应用实例
 
 代码演示
 
 ```java
package com.atguigu.principle.singleton.type07;

/**
 * @author victor
 * @site https://victorfengming.github.io/
 * @company XDL
 * @project java_mode
 * @package com.atguigu.principle.singleton.type07
 * @created 2021-02-02 20:37
 * @function ""
 */
public class SingletonTest07 {

    public static void main(String[] args) {
        System.out.println("使用静态内部类完成单例设计模式!");
        Singleton ins = Singleton.getInstance();
        Singleton ins2 = Singleton.getInstance();
        System.out.println(ins);
        System.out.println(ins.hashCode());
        System.out.println(ins2);
        System.out.println(ins2.hashCode());
        System.out.println(ins == ins2);
        Singleton ins4 = Singleton.getInstance();
        System.out.println(ins4);
        /*
        * 使用静态内部类完成单例设计模式!
        com.atguigu.principle.singleton.type07.Singleton@1540e19d
        356573597
        com.atguigu.principle.singleton.type07.Singleton@1540e19d
        356573597
        true
        com.atguigu.principle.singleton.type07.Singleton@1540e19d

        * */
    }
}


// 静态内部类完成,推荐使用
class Singleton {
    private static volatile Singleton instance;

    // 构造器私有化
    private Singleton() {

    }

    // 写一个静态累不累,该类中有一个静态的属性,这个静态属性他有一个类型就是,Singleton
    private static class SingletonInstance {
        // 通过jvm底层装载机制保证了,这个是线程安全的
        private static final Singleton INSTANCE = new Singleton();
    }

    // 提供一个静态公有方法,直接返回SingletonInstance.INSTANCE
    public static Singleton getInstance() {
        return SingletonInstance.INSTANCE;
    }
}
```
 
 
 优缺点说明:
 
 1. 这种方式采用了类装载的机制来保证初始化实例时只有一个线程
 
 2. 静态内部类方式在Singleton类被装载时并不会立即实例化,而是在需要实例化时,调用getInstance方法,才会装载SingletonInstance类,从而完成Singleton的实例化.
 
 3. 类的静态属性只会在第一次加载类的时候初始化,所以在这里,JVM帮助我们保证了线程的安全性,在类进行初始化时,别的线程时无法进入的
 
 4. 优点: 避免了 __线程不安全__ ,利用静态内部类特点实现延迟加载,效率高
 
 5. 结论: 推荐使用
 
 
 
 
 
 
 