{"./":{"url":"./","title":"Introduction","keywords":"","body":"Go!!!IntroductionJava 设计模式简易目录Go!!! 导航:课件大全 Introduction 视频教程地址:尚硅谷Java设计模式（图解+框架源码剖析） gitee仓库地址:design_pattern Java 设计模式 设计模式(英语 design pattern)是对面向对象设计中反复出现的问题的解决方案。这个术语是在1990年代由Erich Gamma等人从建筑设计领域引入到计算机科学中来的。 这个术语的含义还存有争议。算法不是设计模式，因为算法致力于解决问题而非设计问题。设计模式通常描述了一组相互紧密作用的类与对象。 设计模式提供一种讨论软件设计的公共语言，使得熟练设计者的设计经验可以被初学者和其他设计者掌握。设计模式还为软件重构提供了目标。 更多资料: 在这里 简易目录 序 七大设计原则 工具 1.单例模式 2.工厂模式 3.原型模式 4.建造者模式 5.适配器模式 6.桥接模式 7.装饰者模式 8.组合模式 9.外观模式 10.享元模式 12.代理模式 13.模板模式 14.命令模式 15.访问者模式 16.迭代器模式 17.观察者模式 18.终结者模式 19.备忘录模式 20.解释器模式 21.状态模式 22.策略模式 23.职责链模式 参考: 简说设计模式 哪些设计模式最值得学习 菜鸟教程 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"01_设计抹水泥面试题.html":{"url":"01_设计抹水泥面试题.html","title":"设计模式面试题","keywords":"","body":"圆形设计模式问题: 有请使用UML类图画出原形模式核心角色 原型设计模式的深拷贝和浅拷贝是什么,并写出深拷贝的两种方式的源码(重写clone方法实现深拷贝,,使用序列化来实现深拷贝) 在Spring框架中哪里使用到原型模式,并对源码进行分析beans.xml 然后他就问题,要求这个spring的配置这行代码,对应的源码是哪一段儿 他这个就要求,你对于使用过spring过后,对于源码要了解 设计模式的七大原则:要求: 1) 七大设计原则核心思想 2)能够以类图的说明设计原则 3)在项目实际开发中,你在哪里使用到了ocp原则 设计模式常用的七大原则有: 单一职责原则 接口隔离原则 依赖倒转原则 里氏替换原则 开闭原则ocp 迪米特法则 合成复用原则 比如我们在工厂模式中就使用了 题目 金融借贷平台项目: 借贷平台的订单,有审核-发布-抢单 等等 步骤,随着操作的不同,会改变订单的状态,项目中的这个模块实现就会使用到这个状态,请你使用状态模式记性设计,并完成实际代码 问题分析: 这类代码难以应对变化,在添加一种状态时,我们需要手动添加if/else,在添加一种功能时,要对所有的状态进行判断.因此代码会变得越来越臃肿,并且一旦没有处理某个状态,便会发生极其严重的BUG,难以维护 单机射击模式有一共有8种写法,后面哦们会一起讲到 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-05 22:49:46 "},"02_设计模式概述.html":{"url":"02_设计模式概述.html","title":"设计模式概述","keywords":"","body":"　　设计模式是一个很重要的内容，接下来将逐步的介绍一下常用的23种设计模式及其它的一些设计模式，每一个设计模式都配有模板代码和简单测试用例方便理解，完整代码会逐步上传到码云中，链接放上：https://gitee.com/adamjiangwh/GoF。 ​ 本篇主要介绍一下设计模式的基本原则，并给出目录。 一、什么是设计模式 ​ 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 二、设计模式的基本原则 　　1. 单一职责原则（Single Responsibility Principle，SRP） ​ 类的职责要单一。就一个类而言，应该仅有一个引起它变化的原因。 ​ 举个简单的例子，我们现在很多时候都直接使用手机拍照，但新闻、时尚杂志等的拍照使用的是相机。手机其实就相当于把相机耦合到手机中去了，而相机却只有拍照这一个职责。大多数时候，一件产品简单一些，职责单一一些，或许是更好的选择，这就是单一职责原则。 ​ 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其它职责的能力。 　　2. 开闭原则（Open Close Principle，OCP） ​ 软件实体可扩展，但不可修改。 ​ 就好比“一国两制”，一个国家有两种制度，没有修改原有的管理制度，而是增加了一种新的制度。正所谓对于扩展的开放的，对于更改是封闭的。 　　3. 依赖倒转原则（Dependence Inversion Principle，DIP） ​ 高层模块不应该依赖底层模块，两个都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。后面这句话换个方式说就是针对接口编程，不要对实现编程。 ​ 举个例子，就好比你的电脑，如果CPU、内存、硬盘都需要依赖具体的主板，主板坏了，所有的部件都不能用了，这显然是不合理的。 ​ 换句话说，即谁也不要依赖谁，除了约定的接口，大家都可以灵活自如。 　　4. 里氏代换原则（Liskov Substitution Principle，LSP） ​ 子类型必须能够替换掉它们的父类型。 ​ 举个例子，假如现在父类是鸟类，有个属性是可以飞，子类有个企鹅类，那么很明显企鹅类不能继承鸟类，因为鸟类有会飞的属性，如果子类企鹅类继承父类鸟类，则企鹅必须会飞。 　　5. 接口隔离原则（Interface Segregation Principle，ISP） ​ 接口尽量细化，同时接口中的方法尽量少。 ​ 举个设计模式之禅中的例子，星探找美女，星探要去找美女，他需要通过一个标准来找，比如可以分为外形美女和气质美女（即两个接口），这样不管以后是要气质美女还是外形美女，都可以保持接口的稳定。 　　6. 迪米特法则（Law of Demeter，LoD）/最少知识原则（Least Knowledge Principle，LKP） ​ 一个类对自己依赖的类知道的越少越好；一个对象应该对其他对象有最少的了解。 ​ 比如体育老师上课前清点人数，他让体育委员来替他清点人数，之后再由体育委员告知结果即可，老师本身并没有接触到其他学生。 ​ 换句话说，每个类都应该尽量降低成员的访问权限，强调了类之间的松耦合。 　　7. 合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP） ​ 尽量使用合成/聚合，尽量不要使用类继承。 ​ 合成表示一种强的“拥有”关系，体现了严格的部分与整体的关系，他们的生命周期相同；而聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。 ​ 这里再举个简单的例子，大雁与翅膀是合成关系；而每只大雁都属于一个雁群，即一个雁群可以有多只大雁，所以大雁和雁群是聚合关系。 三、设计模式的类型 ​ 常见的设计模式有23种，这些模式可分为三大类：创建型模式、结构型模式、行为型模式。 ​ 创建型模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象；结构型模式主要关注类和对象的组合；行为型模式特别关注对象间的通信。 ​ 下面给出一个目录，至于扩展的新模式后续有机会会继续更新。 创建型模式： 单例模式 工厂模式- (工厂模式） 抽象工厂模式 建造者模式 - (生成器模式） 原型模式 结构型模式： 适配器模式 - (变压器模式/包装模式） 桥接模式 - (桥梁模式） 组合模式 - (合成模式/部分-整体模式） 装饰模式 - (装饰器模式） 外观模式 - (门面模式） 享元模式 代理模式 - (委托模式） 行为型模式： 观察者模式 - (发布订阅模式） 模板方法模式 命令模式 状态模式 职责链模式 - (责任链模式） 解释器模式 中介者模式 访问者模式 策略模式 - (政策模式） 备忘录模式 迭代器模式 分类: GoF设计模式 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"03_何时会用到设计模式.html":{"url":"03_何时会用到设计模式.html","title":"何时会用到设计模式","keywords":"","body":"设计模式的重要性 软件工程中,设计模式(design pattern)是对软件设计中普遍存在(反复出现的各种问题,所提出的解决方案.这个术语是有 埃里希加码) 大厦vs 简易房子 拿实际工作经历来说,当一个项目开发完后,如果客户提出增新功能怎么办?(可扩展性,使用设计模式,软件具有很好的扩展性) 如果项目开发完后,原来程序员离职,你接手维护该项目该怎么办?(维护性[可读性,规范性]) 目前程序员们的门槛越来越高,一线IT公司(大厂),都会问你在实际项目中使用过什么设计模式,怎么样使用的,解决了什么问题 设计模式在软件中哪里? 面向对象(oo)=>功能模块[设计模式+算法(数据结构)]=>框架[使用到很多设计模式]=>架构[服务器集群] 如果想成为合格软件工程师,那就花时间连研究下设计模式是非常必要的 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-04 18:09:35 "},"04_授课方式.html":{"url":"04_授课方式.html","title":"授课方式","keywords":"","body":"Java设计模式内容介绍课程两点和授课方式注意举例传统的方式引出建造者模式Java设计模式内容介绍 课程两点和授课方式 课程深入,非倾听点水 课程成体系,非星星点灯 高效儿愉快的学习,设计模式很有用,其实也很好玩,很像小时候搭积木,怎么样搭建更加稳固,坚固 设计模式很重要,因为包含很多编程思想,还是有一定难度的,我们努力做到通俗易懂 采用 应用场景-> 设计模式 -> 剖析原理 -> 分析实现步骤(图解) -> 代码实现 -> 框架或项目源码分析(找到使用的地方) 的步骤讲解[比如: 建造者模式] 课程目标: 让大家掌握本质,达能在工作中灵活运用解决实例问题和优化程序结构的目的. 注意 有时候会觉得设计模式,多此一举,简单的问题搞的很复杂 设计模式是站在一个软件,项目稳定性的角度来思考的,而不知是站在我们这个功能性的角度来思考的 举例 首先我提出一个需求,我要改一个房子 需要建房子: 这一过程为打桩,砌墙,封顶 房子有各种各样的,比如普通房,高楼,别墅,各种房子的过程虽然一样,但是要求不要相同的 请编写程序完成需求 建造者模式解决盖房子问题思路分析+代码实现(尽量配类图) 比如我们吧这个源码拿出来分析, java.lang.StringBuilder中的建造者模式 代码说明+Debug源码 传统的方式引出建造者模式 建造者模式(Builder Pattern)又叫生成器模式,是一种对象构建模式.他可以将复杂对象的建造过程抽象出来(抽象类别),使这个抽象过程的不同实现方法可以构造出不同表现(属性)的对象. 建造者模式是一步一步创建一个复杂的对象,他允许用户只通过指定复杂对象的类型和内容就可以构建它们,用户不需要知道内部的具体构建细节. new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-05 22:50:25 "},"05_七大原则.html":{"url":"05_七大原则.html","title":"七大原则概述","keywords":"","body":"设计模式的7大原则设计模式的7大原则 设计模式的目的 编写软件的过程中,程序员面临的问题一些挑战: 耦合性 内聚性 可维护性 可扩展性 重用性 灵活性 设计模式是为了让(程序)软件,具有更好的 代码重用性(即: 相同功能的代码,不能多次编写) 可读性 (即: 编程的规范性,规范性好了,便于其他程序员的阅读和理解) 可扩展性 (即: 当需要增加新的功能时,非常的方便,也程之为可维护性) 可靠性 (即: 当我们增加新的功能后,对原来的功能没有影响) 使程序呈现高内聚,低耦合的特性 分析金句: 设计模式包含了面向对象的精髓,\"懂了设计模式,你就懂了面向对象分析和设计(OOA/D)的精要\" Scott Mayers 在其巨著 就曾经说过: C++老手和新手的区别就是前者手背上有很多疤痕(他指定是没有碰到很多坑,一个优秀的xxx,一定是伤痕累累) 设计模式7大原则 设计模式原则,其实就是程序员在编程时,应当遵守的原则,也是各种设计模式的基础(即: 设计模式为什么这样设计的依据) 设计模式常用的七大原则有: 单一职责原则 接口隔离原则 依赖倒转原则 里氏替换原则 开闭原则 迪米特法则 合成复用原则 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"06_单一职责原则.html":{"url":"06_单一职责原则.html","title":"单一职责原则","keywords":"","body":"单一职责原则基本介绍单一职责原则注意事项和细节单一职责原则 基本介绍 对类来说,即一个类应该只负责一项职责, 比如类A 负责两个不同职责: 职责1, 职责2. 当职责1 需求变更而改变A时,可能造成职责2执行错误,所以需要将类A,的粒度分解为A1,A2 单一职责原则注意事项和细节 降低类复杂度,一个类只负责一项职责 提高类的可读性,可维护性 降低变更引起的风险 通常情况下,我们应当遵守单一职责原则,只有逻辑足够简单,才可以在代码级违反单一职责原则;只有类中方法为数据足够少,可以在方法级别保持单一职责原则 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 20:17:38 "},"08_接口隔离原则.html":{"url":"08_接口隔离原则.html","title":"接口隔离原则","keywords":"","body":"接口隔离原则接口隔离原则 基本介绍 客户端不应该依赖它不需要的接口,即一个类对另一个类的依赖应该建立在最小的接口上 先看一张图: 类A通过接口Interface1依赖B,类C通过接口Interface1依赖D,如果接口interface1对于类A和类C来说不是最小接口,那么类B和类D比如去实现他们不需要的方法. 按隔离原则应当这样处理: 将接口Interface1拆分为独立的几个接口,类A和类C分别与他们需要的接口建立依赖关系.也就是采用 接口隔离原则 应传统方法的问题和使用接口隔离原则改进 类A通过接口Interface1依赖类B,类C通过接口Interface1依赖类D,如果接口Interface1对于类A和类C来说不是最小接口,那么类B和类D必须去实现他们不需要的方法 将接口Interface1拆分为独立的几个接口,类A和类C分别与他们需要的接口建立依赖关系.也就是采用接口隔离原则. 接口Interface1中出现的方法,根据实际情况拆分为三个接口 代码实现... 新的类图 总结 拆分接口 原则 嗯 代码 案例 类图 分析思路 (通过拆分接口,一个接口只供一个类来调用实现) new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-04 18:09:35 "},"11_依赖倒转原则.html":{"url":"11_依赖倒转原则.html","title":"依赖倒转原则","keywords":"","body":"依赖倒转依赖倒转 基本介绍 依赖倒转原则(dependence inversion principle)是指: 高层模块不应该依赖低层模块,二者都应该依赖其抽象 抽象不应该依赖细节,细节应该依赖抽象 依赖倒装(倒置)的中心思想,是面向接口编程 依赖倒转原则是基于这样的设计理念: 相对于细节的多变性,抽象的东西要稳定的多.以抽象为基础搭建的架构比以细节为基础的架构要稳定的多. 在java中,抽象指的是接口或抽象类,细节就是具体的实现类 使用接口或抽象类的目的是指定好规范,而不涉及任何具体的操作,把展现细节的任务交给他们的实现类去完成 使用案例 请编程完成Person 接收消息 依赖关系传递的三种方式和应用案例 接口传递 构造方法传递 setter方式传递 小结 依赖倒装原则的注意事项和细节 低层模块尽量都要有抽象类或接口,或者两者都有,程序稳定性更好 变量的声明类型尽量是抽象类或接口,这样我们的变量引用和实际对象间,就存在一个缓冲层,利于程序扩展和优化 集成时遵循 里氏替换原则 单一职责 接口隔离 依赖倒转 就是依赖之间要有一个缓冲层,(接口) new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"14_里氏替换原则.html":{"url":"14_里氏替换原则.html","title":"里氏替换原则","keywords":"","body":"里氏替换原则 oo中的继承性的思考和说明 集成包含这样一层含义: 父类中凡是已经实现好的方法,实力上是在设定规范和契约,虽然它不强制要求所有的子类必须遵循这些契约,但是如果子类对这些已经实现的方法任意修改,就会对整个继承体系造成破坏. 继承在给程序设计带来便利的同时,也带来了弊端,比如使用基层会给程序带来侵入性,程序的可移植性降低,增加对象间的耦合性,如果一个类被其他的类所继承,则当这个类需要修改时,比如考虑到所有的子类,并且父类修改后,所有涉及到子类的功能都有可能产生故障 问题提出: 在编程中,如何正确的使用继承? => 里氏替换原则 总结: 父类改完子类崩了 基本介绍 里氏替换原则 在1988 麻省理工 那个女人 性\"里\" 如果对每个类型为T1对象o1,都有类型为T2对象o2,使得以T1定义是所有程序P在所有的对象o1都代换成o2时,程序P的行为没有发生变化,那么类型T2是类型T1的子类型. 换句话说,所有引用基类的地方必须能够透明地使用其子类的对象 在使用继承时,遵循里氏替换原则,在子类中尽量不要重写父类的方法 里氏替换原则告诉我们,继承实际上让两个类耦合性增强了,在适当的情况下,可以通过 聚合,组合,依赖 来解决问题. 总结: 就是不能在继承的情况下来重写父类的方法 (比如原来是B类继承A类,但是 B类重写了A的所有方法) 可以这样改进: 在创建一个更加基础的类Base,让A和B都继承Base,这样就将A和B类之间的耦合降低了,把他们更加普通的方法提取出来,到base去 历史替换原则 解决方法 我们发现原来运行正常的相减发生了错误.原因就是类B无意中重写了父类的方法,造成原有功能出现错误. 在实际编程中,我们常常会通过重写父类方法完成新的功能,这样写起来虽然很简单,但是整个继承体系的复用性会比较差. 特别是运行多态比较频繁的时候 通用的做法是: 原来的父类和子类都继承一个更通俗的基类,原有的集成关系去掉,采用依赖,聚合,组合等关系代替. new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-04 18:09:35 "},"16_开闭原则.html":{"url":"16_开闭原则.html","title":"OCP开闭原则","keywords":"","body":"开闭原则概念基本介绍方式1 的优点方式1 改进的思路分析开闭原则 概念 开闭原则(Open Closed Principle) 是编程中最基础,最重要的设计原则 一个软件实体如类,模块和函数应该对扩展开放(对提供方),对修改关闭(对使用方).用抽象构建框架,用实现扩展细节. 当软件需要变化时,尽量通过扩展软件实体的行为来实现变化,而不是通过修改已有的代码来实现变化. 编程中遵循其他原则,以及使用设计模式的目的就是遵循开闭原则 装饰器 基本介绍 对功能开放,对调用方关闭 方式1 的优点 优点是比较好理解,简单呐易操作 缺点是违反了设计模式的ocp原则,即 对扩展开放(提供方),对修改关闭(使用方) 即当我们给类增加新功能的时候,尽量不修改代码,或者尽可能少修改代码. 比如我们这时要新增加一个图形种类 三角形,我们需要做如下修改,修改的地方较多 代码演示 方式1 改进的思路分析 改进的思路 思路: 吧创建Shape类做成抽象类,并提供一个抽象的draw方法,让子类去实现即可,这样我们有新的图形种类时,只需要让新的图形类继承Shape,并实现draw方法即可,使用方的代码就不需要修改 -> 满足了开闭原则 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"19_迪米特法则.html":{"url":"19_迪米特法则.html","title":"迪米特法则","keywords":"","body":"迪米特法则单一职责 接口隔离 依赖倒置 里氏替换 开闭原则 迪米特法则应用实例应用实例改进迪米特法则注意事项和细节迪米特法则 基本介绍 一个对象应该对其他对象保持最少的了解 类与类关系越密切,耦合度越大 迪米特法则( Demeter Principle) 又叫 最少知道原则,即一个类对自己依赖的类知道越少越好.也就是说,对于被依赖的类不管多么复杂,都尽量将逻辑封装在类的内部.对外除了提供的public方法,不对外泄露任何信息. 迪米特法则还有更简单的定义: 只与直接的朋友通信 直接的朋友: 每个对象都会与其他对象有耦合关系,只要两个对象之间有耦合关系,我们就说这两个对象之间是朋友关系.耦合的方式很多,依赖,关联,组合,聚合等.其中,我们称出现成员变量,方法参数,方法返回值中的类为直接的朋友,而出现在局部变量中的类不是直接的朋友.也就是说,陌生的类最好不要以局部变量的形式出现在类的内部. 单一职责 接口隔离 依赖倒置 里氏替换 开闭原则 迪米特法则 直接朋友: A中有B, 比如A接收参数列表中有B的实例对象,或者是A的返回值列表中存在B的实例对象,但是都是要是对完有B的影子,A和B才是直接朋友 倘若,A里面有个私有方法C,然后C,new到了B,这个就不算A与B为直接朋友 所以,这个迪米特法则就是说,这个陌生的类,就怎么说,就陌生的类最好不要以这个局部变量的形式存在在其他类的内部哦 应用实例 有一个学校,下属有各个学院和总部,现要求打印出学校总部员工ID和学院员工的ID 编程实现上面的功能,看代码演示 学院员工id = 0 学院员工id = 1 学院员工id = 2 学院员工id = 3 学院员工id = 4 学院员工id = 5 学院员工id = 6 学院员工id = 7 学院员工id = 8 学院员工id = 9 --- 学校总部员工 --- 学校总部员工id = 0 学校总部员工id = 1 学校总部员工id = 2 学校总部员工id = 3 学校总部员工id = 4 -- 应用实例改进 前面设计的问题在于SchoolManager中,CollegeEmployee类并不是SchoolManager类的直接朋友(分析) 按照迪米特法则,应该避免类中出现这样非直接朋友关系的耦合 对代码按照迪米特法则进行改进 迪米特法则注意事项和细节 迪米特法则的核心是降低类之间的耦合 但是注意: 由于每个类都减少了不必要的依赖,因此迪米特法则只是要降低类间(对象间)耦合关系,并不是要求完全没有依赖关系. 最少知道原则 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-04 18:09:35 "},"22_合成复用原则.html":{"url":"22_合成复用原则.html","title":"合成复用原则","keywords":"","body":"合成复用原则依赖,泛化,实现,关联,聚合,组合 合成复用原则 Composite Reuse Principle 基本介绍 原则是尽量使用 合成/聚合 的方式,而不是使用 继承 画类图 如果我们只是想要 B类使用A类的方法 使用继承就会让B类和A类的耦合性增强 如果A类还有其他的类被继承,就耦合性更强了 因此 我们这样去做 我在B里面,(简单的依赖,)用一种方法,将A传递进来(传递一个A的对象实例进来) 还有,我用这个B的一个属性,是这个A的对象实例 这种情况,就是把A聚合到B里面 还有,在属性中 new 出来 A a = new A() 这样A和B的关系就构成组合的关系 设计原则核心思想 找出应用中可能需要变化之处,把它们独立出来,不要和那些不需要变化的代码混在一起 针对 接口 编程,而不是针对 实现 编程 为了交互对象之间的 松耦合 设计而努力 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"23_UML相关.html":{"url":"23_UML相关.html","title":"UML相关","keywords":"","body":"UMLUML 基本介绍 uml-unified modeling language UMl(统一建模语言),是一种用于软件系统分析和设计的语言工具,它用于帮助软件开发人员进行思考和记录思路的结果 UML本身是一套符号的规定,就像数学符号和化学符号一样,这些符号用于描述软件模型中的各个元素和他们之间的关系,比如类,接口,实现,泛化,依赖,组合,聚合,等 使用UML来建模,常用的工具由于Rational Rose,也可以使用一些插件来建模 idea 实现的类图 eclipse 中的 插件 一个插件教程 UML图 画UML图与写文章差不多,都是把自己的思想描述给别人看,关键在于思路和条理,UML图分类: 用例图(use case) 静态结构图: 类图,对象图,包图,组件图,部署图 动态行为图: 交互图(时序图与协作图),状态图,活动图 说明: 类图是描述类与类之间的关系的,是UML图中最核心的 在讲解设计模式时,我们必然会使用类图,为了让学员们能够把设计模式学到位,需要先给大家讲解类图 温馨提示: 如果已经掌握UML类图的学员,可以直接听设计模式的章节 类图 用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系. 类之间的关系:依赖,泛化(继承),实现,关联,聚合与组合 举例 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-04 18:09:35 "},"25_类的依赖泛化_依赖关系.html":{"url":"25_类的依赖泛化_依赖关系.html","title":"类的依赖泛化_依赖关系","keywords":"","body":"类图 - 依赖关系(Dependence)类图 - 依赖关系(Dependence) 只要是在类中用到了对方,那么他们之间就存在依赖关系. 如果没有对方,连编译都通过不了 泛化关系实际上就是继承关系, 他是 依赖关系的特例 类图 - 关联关系(Association) 一对一关系 单向一对一关系 类图 - 聚合关系 聚合关系是关联关系的一种特例 单聚合,多重聚合 整体与部分不可以分开就是 聚合 可以分开就是 组合 =--- new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"26_设计模式扩展.html":{"url":"26_设计模式扩展.html","title":"设计模式扩展","keywords":"","body":"掌握设计模式的层级 第一层:刚开始学编程不久,听说过什么是设计模式 有很长时间经验,自己写了很多代码,其中用到了设计模式,但是自己确不知道 第三层: 学习过了设计模式,发现自己已经在使用了,并且发现了一些新的模式挺好用的 第四层: 阅读了很多别人写的源码和框架,在其中看到别人设计模式,并且能够领会 设计模式的精妙和带来的好处 第五层:代码写着写着,自己都没意识到使用了设计模式,并且熟练的写了出来. 设计模式介绍 设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验,模式不是代码,而是某类问题的通用解决方案,设计模式(Design pattern)代表了 最佳的实践.这些解决方案是众多软件开发人员经过相当长的一段时间的实验和错误总结出来的 2.设计模式的本质提高 软件的维护性,通用性和扩展性,并降低软件的复杂度. > 是经典的书,作者是 Erich Gamma,Richard Helm,Ralph Johnson 和John Vlissides Design(俗称 \"四人组 GOF\") 设计模式并不局限于某种语言,java,php,c++ 都有设计模式 设计模式类型 设计模式分为3种类型,共23种 创建型模式: 单例模式,抽象工厂模式,原型模式,建造者模式,工厂模式 结构性模式: 适配器模式,桥接模式,装饰模式,组合模式,外观模式,享元模式,代理模式 行为型模式: 模板方法模式,命令模式,访问者模式,迭代器模式,观察者模式,中介者模式,备忘录模式,解释器模式(Interpreter模式),状态模式,策略模式,职责链模式(责任链模式) 注意: 不同的书籍上对分类和名称略有差别 比如 你要是不按照这个装饰者模式来整,就会出现嗯类爆炸的问题 类和方法更加的合理 设计模式简介new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"29_单例_饿汉_静态常量.html":{"url":"29_单例_饿汉_静态常量.html","title":"饿汉_静态常量","keywords":"","body":"单例恶汉式单例 所谓单例设计模式,即时采取一定的方法保证在整个软件系统当中,对于某个类只能存在一个对象实例,并且该类只提供一个其对象实例的方法(静态方法) 恶汉式 优缺点说明: 优点:这种写法比较简单,就是在类装载的时候就完成实例化.避免了线程同步问题 缺点: 在类装载的时候就完成了实例化,没有达到Lazy Loading的效果.如果从始至终都没有使用过这个实例,就会造成内存的浪费 这种方式基于ClassLoader机制避免了多线程同步问题,不过,instance在类装载的时就实例化,在单例模式中大多数都是调用getInstance方法,但是导致类装载的原因有很多种,因此不能确定有其他方式(或者其他静态方法)导致这个类被装载,这时候初始化instance就没有达到lazy loading的效果 结论: 这种单例模式可用,可能 造成内存浪费 代码演示 package com.atguigu.principle.singleton.type1; /** */ public class SingletonTest01 { // 1. 构造器私有化,外部不可以new private SingletonTest01() { } // 2. 本类内部创建对象实例 // 恶汉破不及待 new 这个 对象 private final static SingletonTest01 instance = new SingletonTest01(); // 3. 提供一个工友的静态方法,返回实例对象 public static SingletonTest01 getInstance() { return instance; } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 17:27:51 "},"30_单例_饿汉_静态代码块儿.html":{"url":"30_单例_饿汉_静态代码块儿.html","title":"饿汉_静态代码块儿","keywords":"","body":"恶汉式(静态代码块儿)恶汉式(静态代码块儿) 优缺点说明: 这种方式和上面的相似,只不过将类实例化的过程放在了静态代码块中,也是在类装载的时候,就执行静态代码块儿中的代码,初始化类的实例.优缺点和上面是一样的. 结论: 这种单例模式可用,可能 造成内存浪费 代码演示 package com.atguigu.principle.singleton.type02; /** * @author victor * @site https://victorfengming.github.io/ * @company XDL * @project java_mode * @package com.atguigu.principle.singleton.type02 * @created 2021-02-02 18:55 * @function \"\" */ // public class Singleton { // 1. 构造器私有化,外部不可以new private Singleton() { } // 2. 本类内部创建对象实例 private static Singleton instance; static { // 在静态代码块儿中,创建单例对象 instance = new Singleton(); } // 3. 提供一个工友的静态方法,返回实例对象 public static Singleton getInstance() { return instance; } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-06 22:21:28 "},"31_单例_线程不安全_懒汉式.html":{"url":"31_单例_线程不安全_懒汉式.html","title":"线程不安全_懒汉式","keywords":"","body":"懒汉式(线程不安全)懒汉式(线程不安全) 优缺点说明 起到了Lazy Loading的效果,但是只能在单线程下使用 如果在多线程下, 一个线程进入if(singleton == null)判断 语句块,还未来得及往下执行,另一个线程也通过了这个判断语句,这时便会产生多个实例. 所以在多线程的环境下,不可使用种方式 结论:在实例开发中,不要使用这种方式(因为他有潜在的危险,就不能用,他就有错误了,不可用,不可用,不可用!) 代码演示 package com.atguigu.principle.singleton.type03; public class SingletonTest03 { public static void main(String[] args) { } } class Singleton{ private static Singleton instance; private Singleton() { } // 提供一个静态的公有方法,当使用到该方法时,才去创建instance // 即懒汉式 public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"32_单例_线程安全_懒汉式.html":{"url":"32_单例_线程安全_懒汉式.html","title":"线程安全_懒汉式","keywords":"","body":"懒汉式(线程安全)懒汉式(线程安全) 有缺点说明 解决了线程不安全问题 效率太低了,每个线程在想获得类的实例时候,执行getInstance()方法都要进行同步.而其实这个方法只执行了一次实例化代码就够了,后面的想获取该类实例,直接return就行了.方法进行同步效率太低 结论: 在实际开发中,不推荐使用这种方式 代码演示 package com.atguigu.principle.singleton.type04; /** * @author victor * @site https://victorfengming.github.io/ * @company XDL * @project java_mode * @package com.atguigu.principle.singleton.type04 * @created 2021-02-02 19:29 * @function \"\" */ public class Singleton04 { public static void main(String[] args) { Singleton ins = Singleton.getInstance(); Singleton ins2 = Singleton.getInstance(); System.out.println(ins); System.out.println(ins.hashCode()); System.out.println(ins2); System.out.println(ins2.hashCode()); System.out.println(ins == ins2); } } // 懒汉式 (线程安全_ 同步放法_) class Singleton{ private static Singleton instance; private Singleton() { } // 提供一个静态的公有方法 加入了同步处理的代码 // 解决线程安全问题 // 即懒汉式 // 我们在这里加一个关键字 synchronized public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"33_单例_同步代码块_懒汉式.html":{"url":"33_单例_同步代码块_懒汉式.html","title":"同步代码块_懒汉式","keywords":"","body":"懒汉式(线程安全,同步代码块儿)懒汉式(线程安全,同步代码块儿) 代码演示 // 懒汉式 (线程安全_ 同步放法_) class Singleton{ private static Singleton instance; private Singleton() { } // 提供一个静态的公有方法 加入了同步处理的代码 // 解决线程安全问题 // 即懒汉式 // 我们在这里加一个关键字 synchronized public static Singleton getInstance() { if (instance == null) { synchronized(Singleton.class){ instance = new Singleton(); } } return instance; } } 优缺点说明 这总方式,本意是想对于第四种实现方式的改进,因为前面同步方法效率太低, 改为同步产生实例化的的代码块 但是这种同步并不能起到线程同步的作用,跟第三种实现方式遇到的情形一致,假如一个线程进入了if(singleton == null)判断语句块儿,还未来得及往下执行,另一个线程也通过了这个判断语句,这时便会产生多个实例 结论:在实际开发中,不能使用这种方式(没多大卵用) new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-09 18:28:42 "},"34_单例_双重检查.html":{"url":"34_单例_双重检查.html","title":"双重检查","keywords":"","body":"双重检查双重检查 双重检查应用实例 代码演示: class Singleton{ private static volatile Singleton singleton; private Singleton(){} // 提供一个静态公有方法 public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } // 同步代码,效率是比较低的 // 只是在判断外就走过了 } return instance; } } Java并发编程：volatile关键字解析 优缺点说明 double-check 概念是多线程开发中常使用到的,如代码中所示,我们进行了两次 if(singleton == null)检查,这样就可以保证线程安全了 这样,实例化代码只用执行一次,后面再次访问时候,判断if(singleton==null), 直接return实例化对象,也避免的反复进行方法同步. 线程安全;延迟加载;效率较高 结论:在实际开发中,推荐 使用这种单例设计模式 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-06 22:21:28 "},"35_单例_静态内部类.html":{"url":"35_单例_静态内部类.html","title":"静态内部类","keywords":"","body":"静态内部类静态内部类 静态内部类应用实例 代码演示 package com.atguigu.principle.singleton.type07; /** * @author victor * @site https://victorfengming.github.io/ * @company XDL * @project java_mode * @package com.atguigu.principle.singleton.type07 * @created 2021-02-02 20:37 * @function \"\" */ public class SingletonTest07 { public static void main(String[] args) { System.out.println(\"使用静态内部类完成单例设计模式!\"); Singleton ins = Singleton.getInstance(); Singleton ins2 = Singleton.getInstance(); System.out.println(ins); System.out.println(ins.hashCode()); System.out.println(ins2); System.out.println(ins2.hashCode()); System.out.println(ins == ins2); Singleton ins4 = Singleton.getInstance(); System.out.println(ins4); /* * 使用静态内部类完成单例设计模式! com.atguigu.principle.singleton.type07.Singleton@1540e19d 356573597 com.atguigu.principle.singleton.type07.Singleton@1540e19d 356573597 true com.atguigu.principle.singleton.type07.Singleton@1540e19d * */ } } // 静态内部类完成,推荐使用 class Singleton { private static volatile Singleton instance; // 构造器私有化 private Singleton() { } // 写一个静态累不累,该类中有一个静态的属性,这个静态属性他有一个类型就是,Singleton private static class SingletonInstance { // 通过jvm底层装载机制保证了,这个是线程安全的 private static final Singleton INSTANCE = new Singleton(); } // 提供一个静态公有方法,直接返回SingletonInstance.INSTANCE public static Singleton getInstance() { return SingletonInstance.INSTANCE; } } 优缺点说明: 这种方式采用了类装载的机制来保证初始化实例时只有一个线程 静态内部类方式在Singleton类被装载时并不会立即实例化,而是在需要实例化时,调用getInstance方法,才会装载SingletonInstance类,从而完成Singleton的实例化. 类的静态属性只会在第一次加载类的时候初始化,所以在这里,JVM帮助我们保证了线程的安全性,在类进行初始化时,别的线程时无法进入的 优点: 避免了 线程不安全 ,利用静态内部类特点实现延迟加载,效率高 结论: 推荐使用 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-06 22:21:28 "},"36_单例_枚举.html":{"url":"36_单例_枚举.html","title":"枚举","keywords":"","body":"枚举更多天马行空枚举 枚举应用实例 代码演示 package com.atguigu.principle.singleton.type08; /** */ public class SingletonTest08 { public static void main(String[] args) { Singleton instance = Singleton.INSTANCE; Singleton instance2 = Singleton.INSTANCE; System.out.println(instance == instance2); System.out.println(instance.hashCode()); System.out.println(instance2.hashCode()); instance.sayOK(); } } // 使用枚举 ,可以实现单例, 推荐使用 enum Singleton{ INSTANCE; public void sayOK() { System.out.println(\"ok~\"); } } 优缺点说明: 这借助jdk1.5天假的枚举来实现单例模式. 不仅能够避免多线程同步问题,而且还能够防止反序列化重新创建新的对象 这种方式 是 Effective Java 作者 Josh Bloch 提倡的方式 结论: 推荐使用 更多 参考:你知道吗？枚举单例模式是世界上最好的单例模式！！！ 天马行空 如果不考虑前轮打滑,前驱是最好的驱动形式 如果不考虑钢带打滑,CVT是最好的变速箱 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-09 18:28:42 "},"37_单例_JDK源码.html":{"url":"37_单例_JDK源码.html","title":"JDK源码","keywords":"","body":"单例模式在JDK应用的源码分析单例模式在JDK应用的源码分析 单例模式在jdk中的源码分析 在我们JDK中,java.lang.Runtime就是经典的单例模式(恶汉式) 代码分析+Debug源码+代码说明 public class Runtime { private static Runtime currentRuntime = new Runtime(); /** * Returns the runtime object associated with the current Java application. * Most of the methods of class Runtime are instance * methods and must be invoked with respect to the current runtime object. * * @return the Runtime object associated with the current * Java application. */ public static Runtime getRuntime() { return currentRuntime; } /** Don't let anyone else instantiate this class */ private Runtime() {} new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-06 22:16:15 "},"38_单例_小结.html":{"url":"38_单例_小结.html","title":"小结","keywords":"","body":"单例设计模式回顾一下一、定义二、用途三、实现方式1、饿汉式2、懒汉式3、双重检测(double check)4、静态内部类5、枚举四、枚举单例模式是世界上最好的单例模式1、JVM级别的线程安全2、防止反序列化的破坏3、防止反射的破坏五、单例模式存在哪些问题?1、单例对 OOP 特性的支持不友好2、单例会隐藏类之间的依赖关系3、单例对代码的扩展性不友好4、单例不支持有参数的构造函数六、单例模式的替代方案七、重新理解单例模式的唯一性1、单例模式的唯一性2、实现线程唯一的单例3、实现集群唯一的单例4、实现一个\"多例\"模式八、枚举源码补充单例设计模式 所谓单例设计模式,即时采取一定的方法保证在整个软件系统当中,对于某个类只能存在一个对象实例,并且该类只提供一个其对象实例的方法(静态方法) 比如Hibernate的SessionFactory. 单例模式注意事项和细节说明 单例模式保证了系统内存中该类只存在一个对象,节省了系统资源,对于一些要频繁创建销毁的对象,使用单例模式可以提高系统性能 当想实例化一个单例类的时候,必须要记住使用相应的获取对象的方法,而不是使用new 单例模式 使用的场景 : 需要 频繁的进行创建 和 销毁的对象,创建对象时耗时过多而耗费资源过多(即: 重量级对象 ),但又经常用到的对象, 工具类对象 ,频繁访问数据库或文件的对象(比如 数据源,session工厂 等) 单例模式有8种方式: 饿汉_静态常量 饿汉_静态代码块儿 线程不安全_懒汉式 线程安全_懒汉式 同步代码块_懒汉式 双重检查 静态内部类 枚举 回顾一下 一、定义 一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。 二、用途 从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如，无状态工具类、全局配置信息类 三、实现方式 以唯一递增 ID 生成器为案例 单例模式有两种模式，饿汉式和懒汉式。 1、饿汉式 饿汉式在类加载的同时就已经创建好一个静态的对象供系统使用，其唯一性和线程安全性都由JVM保证 public class HungryIdGenerator { private static final HungryIdGenerator instance = new HungryIdGenerator(); private AtomicLong id = new AtomicLong(0); private HungryIdGenerator() {} public static HungryIdGenerator getInstance() { return instance; } public long getId() { return id.incrementAndGet(); } } 道听途说 有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化. 这个就是各说各有理了. 不过，我个人并不认同这样的观点，理由如下： 如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），在程序启动时初始化单例，尽早报OOM，以免程序在正常运行时，因为首次加载单例突然OOM导致系统崩溃。 如果加载比较耗时，更应该在程序启动时初始化好单例了，而不是在程序运行中占用正常请求的时长，导致请求缓慢甚至超时报错 总结一句话,提前创建提前发现错误,免得崩溃了就晚了 2、懒汉式 懒汉式相对于饿汉式的优势是支持延迟加载。在对外提供的方法内实例化，需要线程安全的处理。 public class LazyIdGenerator { private AtomicLong id = new AtomicLong(0); private static volatile LazyIdGenerator instance = null; private LazyIdGenerator() {} public static synchronized LazyIdGenerator getInstance() { if (instance != null) { return instance; } instance = new LazyIdGenerator(); return instance; } public long getId() { return id.incrementAndGet(); } } 把synchronized加在方法上，使得每次获得实例都要同步，开销很大，性能很低。强烈不推荐这种方式实现单例 3、双重检测(double check) 双重检测是懒汉式的升级版，只有在第一次初始化时加锁，以后不会再加锁。个人觉得双重检测的懒汉式与饿汉式不分哪个最优，他们有着不同的应用场景 /** * 懒加载：double check */ public class DoubleCheckIdGenerator { private AtomicLong id = new AtomicLong(0); private static volatile DoubleCheckIdGenerator instance = null; private DoubleCheckIdGenerator() {} public static DoubleCheckIdGenerator getInstance() { if (instance != null) { return instance; } synchronized (DoubleCheckIdGenerator.class) { if (instance != null) { return instance; } instance = new DoubleCheckIdGenerator(); return instance; } } public long getId() { return id.incrementAndGet(); } } instance 成员变量加了volatile 关键字修饰，是为了防止指令重排，因为instance = new DoubleCheckIdGenerator();并不是一个原子操作，其在JVM中至少做了三件事： 给instance在堆上分配内存空间。(分配内存) 调用DoubleCheckIdGenerator的构造函数等来初始化instance。（初始化） 将instance对象指向分配的内存空间。（执行完这一步instance就不是null了） 在没有volatile修饰时，执行顺序可以是1,2,3，也可以是1,3,2。假设有两个线程，当一个线程先执行了3，还没执行2，此时第二个线程来到第一个check，发现instance不为null，就直接返回了，这就出现问题，这时的instance并没有完全完成初始化 听说高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。但是并没有在官方资料中看到，所以以防万一，还是加上volatile 这个关键字。 4、静态内部类 比双重检测更加简单的实现方法，那就是利用 Java 的静态内部类。它有点类似饿汉式，但又能做到了延迟加载 /** * 懒加载：静态内部类 */ public class StaticInnerClassIdGenerator { private AtomicLong id = new AtomicLong(0); private StaticInnerClassIdGenerator(){} private static class SingletonHolder{ private static final StaticInnerClassIdGenerator instance = new StaticInnerClassIdGenerator(); } public static StaticInnerClassIdGenerator getInstance() { return SingletonHolder.instance; } public long getId() { return id.incrementAndGet(); } } SingletonHolder是一个静态内部类，当外部类 StaticInnerClassIdGenerator被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。 instance 的唯一性、创建过程的线程安全性，都由 JVM来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。 5、枚举 最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。 /** * 枚举单例-饿汉，推荐 */ public enum IdGeneratorEnum { INSTANCE; private AtomicLong id = new AtomicLong(0); public long getId() { return id.incrementAndGet(); } } 四、枚举单例模式是世界上最好的单例模式 饿汉式以及懒汉式中的双重检查式、静态内部类式都无法避免被反序列化和反射生成多个实例。而枚举方式实现的单例模式不仅能避免多线程同步的问题，也可以防止反序列化和反射的破坏。 Joshua Bloch 在《Effective Java》中明确表明，枚举类型实现的单例模式是最佳的方式。 枚举单例模式具有以下三个优点： 写法简洁，代码短小精悍。 线程安全。 防止反序列化和反射的破坏。 通过jad反编译工具将枚举单例反编译： // Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov. // Jad home page: http://www.kpdus.com/jad.html // Decompiler options: packimports(3) // Source File Name: IdGeneratorEnum.java package com.stefan.designPattern.singleton; import java.util.concurrent.atomic.AtomicLong; public final class IdGeneratorEnum extends Enum { public static IdGeneratorEnum[] values() { return (IdGeneratorEnum[])$VALUES.clone(); } public static IdGeneratorEnum valueOf(String name) { return (IdGeneratorEnum)Enum.valueOf(com/stefan/designPattern/singleton/IdGeneratorEnum, name); } private IdGeneratorEnum(String s, int i) { super(s, i); id = new AtomicLong(0L); } public long getId() { return id.incrementAndGet(); } public static final IdGeneratorEnum INSTANCE; private AtomicLong id; private static final IdGeneratorEnum $VALUES[]; static { INSTANCE = new IdGeneratorEnum(\"INSTANCE\", 0); $VALUES = (new IdGeneratorEnum[] { INSTANCE }); } } 1、JVM级别的线程安全 反编译的代码中可以发现枚举中的各个枚举项都是通过static代码块来定义和初始化的，他们会在类被加载时完成初始化，而Java的类加载由JVM保证线程安全。 2、防止反序列化的破坏 Java的序列化专门对枚举的序列化做了规定，在序列化时，只是将枚举对象的name属性输出到结果中，在反序列化时通过java.lang.Enum的valueOf方法根据名字查找对象，而不是新建一个新的对象，所以防止了反序列化对单例的破坏。 可以查看java.io.ObjectInputStream#readObject验证。readObject判断到枚举类时，调用的了这个方法java.io.ObjectInputStream#readEnum private Enum readEnum(boolean unshared) throws IOException { if (this.bin.readByte() != 126) { throw new InternalError(); } else { ObjectStreamClass desc = this.readClassDesc(false); if (!desc.isEnum()) { throw new InvalidClassException(\"non-enum class: \" + desc); } else { int enumHandle = this.handles.assign(unshared ? unsharedMarker : null); ClassNotFoundException resolveEx = desc.getResolveException(); if (resolveEx != null) { this.handles.markException(enumHandle, resolveEx); } String name = this.readString(false); Enum result = null; Class cl = desc.forClass(); if (cl != null) { try { Enum en = Enum.valueOf(cl, name); result = en; } catch (IllegalArgumentException var9) { throw (IOException)(new InvalidObjectException(\"enum constant \" + name + \" does not exist in \" + cl)).initCause(var9); } if (!unshared) { this.handles.setObject(enumHandle, result); } } this.handles.finish(enumHandle); this.passHandle = enumHandle; return result; } } } 3、防止反射的破坏 对于反射，枚举类同样有防御措施，反射在通过newInstance创建对象时会检查这个类是否是枚举类，如果是枚举类就会throw new IllegalArgumentException(\"Cannot reflectively create enum objects\");,如下是源码java.lang.reflect.Constructor#newInstance： public T newInstance(Object... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { if (!this.override) { Class caller = Reflection.getCallerClass(); this.checkAccess(caller, this.clazz, this.clazz, this.modifiers); } if ((this.clazz.getModifiers() & 16384) != 0) { throw new IllegalArgumentException(\"Cannot reflectively create enum objects\"); } else { ConstructorAccessor ca = this.constructorAccessor; if (ca == null) { ca = this.acquireConstructorAccessor(); } T inst = ca.newInstance(initargs); return inst; } } 五、单例模式存在哪些问题? 单例模式有节省资源、保证结果正确、方便管理等优点，同时也存在一些问题 1、单例对 OOP 特性的支持不友好 OOP 的四大特性是封装、抽象、继承、多态。单例模式对于其中的抽象、继承、多态都支持得不好。 就拿唯一递增id生成器来说，上面实现的单例IdGenerator 的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的 OOP 的抽象特性。如果未来某一天，希望针对不同的业务采用不同的 ID 生成算法。比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，我们需要修改所有用到 IdGenerator 类的地方，这样代码的改动就会比较大。 除此之外，单例对继承、多态特性的支持也不友好。从理论上来讲，单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪，导致代码的可读性变差。所以，一旦选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性。 2、单例会隐藏类之间的依赖关系 通过构造函数、参数传递等方式声明的类之间的依赖关系，查看函数的定义，就能很容易识别出来 但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。 如果代码比较复杂，这种调用关系就会非常隐蔽。 3、单例对代码的扩展性不友好 单例类只能有一个对象实例。如果未来某一天，需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动。 拿数据库连接池来举例说明，在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据库连接资源的消耗。所以，初始把数据库连接池类设计成了单例类。后期我们想把慢sql和普通sql进行隔离，这样就需要建立两个数据库连接池实例。但是初始数据库连接池设计成了单例类，显然就无法适应这样的需求变更，也就是说，单例类在某些情况下会影响代码的扩展性和灵活性。 所以，数据库连接池、线程池这类的资源池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设计成单例类。 4、单例不支持有参数的构造函数 单例不支持有参数的构造函数，比如创建一个连接池的单例对象，没法通过参数来指定连接池的大小。解决方式是，将参数配置化。在单例实例化时，从外部读取参数。 六、单例模式的替代方案 为了保证全局唯一，除了使用单例，还可以用静态方法来实现。 这其实就是平时常用的工具类了，但是它比单例更加不灵活，比如，它无法支持延迟加载，扩展性也很差。 public class IdGeneratorUtil { private static AtomicLong id = new AtomicLong(0); public static long getId() { return id.incrementAndGet(); } public static void main(String[] args) { System.out.println(IdGeneratorUtil.getId()); } } 实际上，类对象的全局唯一性可以通过多种不同的方式来保证，单例模式、工厂模式、IOC 容器（比如 Spring IOC 容器），还可以通过自我约束，在编写代码时自我保证不要创建两个对象。 七、重新理解单例模式的唯一性 1、单例模式的唯一性 经典的单例模式，创建的全局唯一对象，属于进程唯一性，如果一个系统部署了多个实例，就有多个进程，每个进程都存在唯一一个对象，且进程间的实例对象不是同一个对象。 2、实现线程唯一的单例 实现线程唯一的单例，就是一个对象在一个线程只能存在一个，不同的线程有不同的对象。 code /** * 线程唯一单例 */ public class ThreadIdGenerator { private AtomicLong id = new AtomicLong(0); private static final ConcurrentHashMap instances = new ConcurrentHashMap(); private ThreadIdGenerator() {} public ThreadIdGenerator getInstance() { long threadId = Thread.currentThread().getId(); instances.putIfAbsent(threadId, new ThreadIdGenerator()); return instances.get(threadId); } public long getId() { return id.incrementAndGet(); } } 在代码中，通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样就可以做到不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 工具类，可以更加轻松地实现线程唯一单例。 /** * 线程唯一单例 ThreadLocal */ public class ThreadLocalIdGenerator { private AtomicLong id = new AtomicLong(0); private static ThreadLocal instances = new ThreadLocal(); private ThreadLocalIdGenerator(){} public static ThreadLocalIdGenerator getIntance() { ThreadLocalIdGenerator instance = instances.get(); if (instance != null) { return instance; } instance = new ThreadLocalIdGenerator(); instances.set(instance); return instance; } public long getId() { return id.incrementAndGet(); } } // 代码测试： public class Test { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread() { @Override public void run() { System.out.println(\"sub1: \" + ThreadLocalIdGenerator.getIntance().toString() + \"-->\" + ThreadLocalIdGenerator.getIntance().getId()); System.out.println(\"sub2: \" + ThreadLocalIdGenerator.getIntance().toString() + \"-->\" + ThreadLocalIdGenerator.getIntance().getId()); } }; thread.start(); thread.join(); System.out.println(\"main1: \" + ThreadLocalIdGenerator.getIntance().toString() + \"-->\" + ThreadLocalIdGenerator.getIntance().getId()); System.out.println(\"main2: \" + ThreadLocalIdGenerator.getIntance().toString() + \"-->\" + ThreadLocalIdGenerator.getIntance().getId()); } } 控制台 sub1: com.stefan.designPattern.singleton.ThreadLocalIdGenerator@480a0d08-->1 sub2: com.stefan.designPattern.singleton.ThreadLocalIdGenerator@480a0d08-->2 main1: com.stefan.designPattern.singleton.ThreadLocalIdGenerator@4f3f5b24-->1 main2: com.stefan.designPattern.singleton.ThreadLocalIdGenerator@4f3f5b24-->2 结论: 显然主线程和子线程生成的单例不是同一个，且一个线程调用多次生成的是同一个单例对象。 3、实现集群唯一的单例 集群代表着有多个进程，实现集群唯一单例，就是进程间共享一个对象。 集群唯一的单例实现起来相对复杂。 （1）需要考虑共享对象存放在哪里， （2）进程创建单例对象时需要加分布式锁，防止多个进程创建多个不同的对象。 4、实现一个\"多例\"模式 “单例”指的是，一个类只能创建一个对象，对应地，“多例”指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。 （1）以map存储多例的方式 /** * 多例模式的唯一自增id生成器 * 用户表一个IdGenerator * 商品表一个IdGenerator * 订单表一个IdGenerator */ public class MultIdGenerator { private AtomicLong id = new AtomicLong(0); private MultIdGenerator() {} public long getId() { return id.incrementAndGet(); } private static Map instances = new HashMap(); static { instances.put(Type.USER, new MultIdGenerator()); instances.put(Type.PRODUCT, new MultIdGenerator()); instances.put(Type.ORDER, new MultIdGenerator()); } public static MultIdGenerator getInstance(String type) { return instances.get(type); } public static final class Type { public static final String USER = \"user\"; public static final String PRODUCT = \"product\"; public static final String ORDER = \"order\"; } } // 测试 public class Test3 { public static void main(String[] args) { System.out.println(\"USER: \" + MultIdGenerator.getInstance(MultIdGenerator.Type.USER).toString() + \"-->\" + MultIdGenerator.getInstance(MultIdGenerator.Type.USER).getId()); System.out.println(\"USER: \" + MultIdGenerator.getInstance(MultIdGenerator.Type.USER).toString() + \"-->\" + MultIdGenerator.getInstance(MultIdGenerator.Type.USER).getId()); System.out.println(\"PRODUCT: \" + MultIdGenerator.getInstance(MultIdGenerator.Type.PRODUCT).toString() + \"-->\" + MultIdGenerator.getInstance(MultIdGenerator.Type.PRODUCT).getId()); System.out.println(\"PRODUCT: \" + MultIdGenerator.getInstance(MultIdGenerator.Type.PRODUCT).toString() + \"-->\" + MultIdGenerator.getInstance(MultIdGenerator.Type.PRODUCT).getId()); System.out.println(\"ORDER: \" + MultIdGenerator.getInstance(MultIdGenerator.Type.ORDER).toString() + \"-->\" + MultIdGenerator.getInstance(MultIdGenerator.Type.ORDER).getId()); System.out.println(\"ORDER: \" + MultIdGenerator.getInstance(MultIdGenerator.Type.ORDER).toString() + \"-->\" + MultIdGenerator.getInstance(MultIdGenerator.Type.ORDER).getId()); } } 控制台 USER: com.stefan.designPattern.singleton.MultIdGenerator@4f3f5b24-->1 USER: com.stefan.designPattern.singleton.MultIdGenerator@4f3f5b24-->2 PRODUCT: com.stefan.designPattern.singleton.MultIdGenerator@15aeb7ab-->1 PRODUCT: com.stefan.designPattern.singleton.MultIdGenerator@15aeb7ab-->2 ORDER: com.stefan.designPattern.singleton.MultIdGenerator@7b23ec81-->1 ORDER: com.stefan.designPattern.singleton.MultIdGenerator@7b23ec81-->2 （2）使用枚举实现多例模式 /** * 多例模式的唯一自增id生成器 * 用户表一个IdGenerator * 商品表一个IdGenerator * 订单表一个IdGenerator * * 枚举无法实现多例模式 */ public enum MultIdGeneratorEnum { USER, PRODUCT, ORDER; private AtomicLong id = new AtomicLong(0); public long getId() { return id.incrementAndGet(); } } // 测试 public class Test2 { public static void main(String[] args) { System.out.println(\"USER: \" + MultIdGeneratorEnum.USER.toString() + \"-->\" + MultIdGeneratorEnum.USER.getId()); System.out.println(\"USER: \" + MultIdGeneratorEnum.USER.toString() + \"-->\" + MultIdGeneratorEnum.USER.getId()); System.out.println(\"PRODUCT: \" + MultIdGeneratorEnum.PRODUCT.toString() + \"-->\" + MultIdGeneratorEnum.PRODUCT.getId()); System.out.println(\"PRODUCT: \" + MultIdGeneratorEnum.PRODUCT.toString() + \"-->\" + MultIdGeneratorEnum.PRODUCT.getId()); System.out.println(\"ORDER: \" + MultIdGeneratorEnum.ORDER.toString() + \"-->\" + MultIdGeneratorEnum.ORDER.getId()); System.out.println(\"ORDER: \" + MultIdGeneratorEnum.ORDER.toString() + \"-->\" + MultIdGeneratorEnum.ORDER.getId()); //USER: USER-->1 //USER: USER-->2 //PRODUCT: PRODUCT-->1 //PRODUCT: PRODUCT-->2 //ORDER: ORDER-->1 //ORDER: ORDER-->2 } } 枚举的方式明显要简洁很多，强烈推荐使用枚举方式实现单例和多例模式。 通过反编译查看源码，枚举方式实现的多例其实和前面以map存储多例的方式差不多的原理，都是用HashMap把实例化对象存储起来。 使用jad反编译MultIdGeneratorEnum.class: // Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov. // Jad home page: http://www.kpdus.com/jad.html // Decompiler options: packimports(3) // Source File Name: MultIdGeneratorEnum.java package com.stefan.designPattern.singleton; import java.util.concurrent.atomic.AtomicLong; public final class MultIdGeneratorEnum extends Enum { public static MultIdGeneratorEnum[] values() { return (MultIdGeneratorEnum[])$VALUES.clone(); } public static MultIdGeneratorEnum valueOf(String name) { return (MultIdGeneratorEnum)Enum.valueOf(com/stefan/designPattern/singleton/MultIdGeneratorEnum, name); } private MultIdGeneratorEnum(String s, int i) { super(s, i); id = new AtomicLong(0L); } public long getId() { return id.incrementAndGet(); } public static final MultIdGeneratorEnum USER; public static final MultIdGeneratorEnum PRODUCT; public static final MultIdGeneratorEnum ORDER; private AtomicLong id; private static final MultIdGeneratorEnum $VALUES[]; static { USER = new MultIdGeneratorEnum(\"USER\", 0); PRODUCT = new MultIdGeneratorEnum(\"PRODUCT\", 1); ORDER = new MultIdGeneratorEnum(\"ORDER\", 2); $VALUES = (new MultIdGeneratorEnum[] { USER, PRODUCT, ORDER }); } } 多例模式很像工厂模式，它跟工厂模式的不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象。 八、枚举源码补充 一个枚举类反编译之后，可以看到其继承自java.lang.Enum，其中有一个valueof的方法是直接调用java.lang.Enum#valueOf的。其底层是一个key为name，value为Enum类型的实例化对象。通过源码可以验证： package java.lang; import java.io.IOException; import java.io.InvalidObjectException; import java.io.ObjectInputStream; import java.io.ObjectStreamException; import java.io.Serializable; public abstract class Enum> implements Comparable, Serializable { private final String name; private final int ordinal; public final String name() { return this.name; } public final int ordinal() { return this.ordinal; } protected Enum(String name, int ordinal) { this.name = name; this.ordinal = ordinal; } public String toString() { return this.name; } public final boolean equals(Object other) { return this == other; } public final int hashCode() { return super.hashCode(); } protected final Object clone() throws CloneNotSupportedException { throw new CloneNotSupportedException(); } public final int compareTo(E o) { if (this.getClass() != o.getClass() && this.getDeclaringClass() != o.getDeclaringClass()) { throw new ClassCastException(); } else { return this.ordinal - o.ordinal; } } public final Class getDeclaringClass() { Class clazz = this.getClass(); Class zuper = clazz.getSuperclass(); return zuper == Enum.class ? clazz : zuper; } public static > T valueOf(Class enumType, String name) { //关键性代码，好比是hashmap缓存 T result = (Enum)enumType.enumConstantDirectory().get(name); if (result != null) { return result; } else if (name == null) { throw new NullPointerException(\"Name is null\"); } else { throw new IllegalArgumentException(\"No enum constant \" + enumType.getCanonicalName() + \".\" + name); } } protected final void finalize() { } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { throw new InvalidObjectException(\"can't deserialize enum\"); } private void readObjectNoData() throws ObjectStreamException { throw new InvalidObjectException(\"can't deserialize enum\"); } } java.lang.Enum#valueOf中第一行代码调用的是java.lang.Class#enumConstantDirectory，部分源码如下，Class类中有一个成员变量是HashMap，原理一目了然。 private transient volatile Map enumConstantDirectory; Map enumConstantDirectory() { Map directory = this.enumConstantDirectory; if (directory == null) { T[] universe = this.getEnumConstantsShared(); if (universe == null) { throw new IllegalArgumentException(this.getName() + \" is not an enum type\"); } directory = new HashMap((int)((float)universe.length / 0.75F) + 1); Object[] var3 = universe; int var4 = universe.length; for(int var5 = 0; var5 本内容转载自:你知道吗？枚举单例模式是世界上最好的单例模式 单例模式new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"39_工厂模式_简单工厂模式.html":{"url":"39_工厂模式_简单工厂模式.html","title":"简单工厂模式","keywords":"","body":"工厂模式简单工厂模式工厂模式 看一个具体的需求 看一个披萨的项目: 要便于披萨种类的扩展,要便于维护 披萨的种类很多(比如, GreekPizz, CheesePizz 等) 披萨的制作有 prepare,bake ,cut,box 完成披萨店订购功能. 类图 使用传统的方式来完成 传统方式的优缺点 优点是比较好理解,简单易操作 缺点是违反了设计模式的 ocp原则 ,开放封闭原则,(即对扩展开放,对修改关闭) 即当我们给类增加新功能的时候,尽量不修改代码,或者尽可能少修改代码 比如我们这个时候要新增一个Pizza种类(cheese披萨),我们需要作出如下修改 // 新增 写 public class CheesePizz extends Pizza{ @Override public void prepare(){ // TODO Auto-gent setName(\"奶酪Pizza\") System.out.println(name+\"preparing\"); } } // 增加一段代码 OrderPizza.java // 写 if(oredrType.equal(\"greek\")){ pizza= new GreekPizz(); }else if(oredrType.equal(\"pepper\")){ pizza= new PepperPizza(); }else if(oredrType.equal(\"cheese\")){ pizza= new CheesePizza(); }else{ break; } 现在就是啥呢 你看奥,这个OrderPizza是客户端,可能会在不同的地方有 多个 OrdeaPizza2 OrdeaPizza3 public class OrderPizza { // 构造器 public OrderPizza() { Pizza pizza = null; String orderType; // 订购披萨类型 do { orderType = getType(); if (orderType.equals(\"greek\")) { pizza = new GreekPizza(); pizza.setName(\"希腊披萨!\"); } else if (orderType.equals(\"cheese\")) { pizza = new CheesePizza(); pizza.setName(\"奶酪披萨!\"); } else { break; } // 输出pizza 制作过程 pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } while (true); } 比如 if (orderType.equals(\"greek\")) { 这个里面的判断语句就要再改改改 这指定是不成的(ocp开放封闭原则就 当他不存在了) 传统的方式的优缺点 改进的思路分析 分析: 修改代码可以接受,到那时如果我们其他的地方也有创建Pizza的代码,就意味着也需要修改,而创建Pizza的代码,往往有多处. 思路: 把创建Pizza对象封装到一个类中,这样我们有新的Pizza种类时,只需要修改该类就可,其他有创建到Pizza对象的代码就不需要修改了 => 简单工厂模式 简单工厂模式 基本介绍 简单工厂模式是属于创建型模式,是工厂模式的一种. 简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例 .简单工厂模式是工厂模式家族中最简单实用的模式 简单工厂模式: 定义了一个创建对象的种类,由这个类来 封装实例化对象的行为 (代码) 在软件开发中,当我们会用到大量的场景某种,某类或者某批对象时,就会使用到工厂模式 . 一句话 把创建实例的权限交给工厂,使用者只是需要通过工厂来拿到实例 类图 工厂模式new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"43_工厂模式_工厂方法模式.html":{"url":"43_工厂模式_工厂方法模式.html","title":"工厂方法模式","keywords":"","body":"工厂方法模式工厂方法模式 看一个新的需求 披萨项目新的需求: 客户在点披萨时,可以点不同口味的披萨,比如 北京的奶酪pizza,北京的胡椒pizza 或者 是伦敦的奶酪pizza,伦敦的胡椒pizza 思路1 使用简单工厂模式,创建出不同的简单工厂类,比如 BJPizzaSimpleFactory、LDPizzaSimpleFactory 等等. 从当前这个案例来说,也是可以的,但是考虑到项目的规模,以及软件的可维护性,可扩展性并不是特别好 思路2 使用工厂方法模式 工厂方法模式介绍 工厂方法模式设计方案: 将披萨项目的实例化功能抽象方法,在不同的口味点餐子类中具体实现 工厂方法模式: 定义了一个创建对象的抽象方法,由子类决定要实例化的类.工厂方法模式将 对象的实例化推迟到子类 . 工厂方法模式应用案例 披萨项目新的需求 ; 客户在点餐的过程中,可以点不同口味的披萨,比如, 北京的奶酪披萨,北京的胡椒披萨,或者是 伦敦的奶酪披萨,伦敦的胡椒披萨 类图演示 代码演示 OrderPizza package com.atguigu.factory.factorymethod.pizzastore.order; import com.atguigu.factory.factorymethod.pizzastore.pizza.Pizza; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; /** * ClassName: OrderPizza * Description: OrderPizza * Date: 2021-02-03 15:21 * * * @author victor * @version 产品版本信息 2021年02月03日15:21分 victor(victorfm@163.com) 新建 * * 修改记录 * @email victorfm@163.com * @project java_mode * @package com.atguigu.factory.factorymethod.pizzastore.order */ public abstract class OrderPizza { // 定义一个抽象方法,createPizza,让各个工行子类自己实现 abstract Pizza createPizza(String orderType); // 构造器 public OrderPizza() { Pizza pizza = null; String orderType; // 订购披萨类型 do { orderType = getType(); //我么在这里直接调用createPizza这个方法 pizza = createPizza(orderType); // 这个createPizza 是由他的工厂子类去实现 // 但是这个创建的方法在本类 他是一个抽象的方法 // // 执行这个披萨的制作过程 pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } while (true); } // 写一个方法,可以获取客户希望订购的披萨种类 private String getType() { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza type:\"); String str = null; try { str = strin.readLine(); } catch (IOException e) { e.printStackTrace(); } return str; } } 北京的奶酪披萨 public class BJCheesePizza extends Pizza{ @Override public void prepare() { setName(\"北京的奶酪披萨\"); System.out.println(\"给北京的奶酪披萨准备原材料!\"); } } 执行类 package com.atguigu.factory.factorymethod.pizzastore.pizza; /** * ClassName: Pizza * Description: Pizza * Date: 2021-02-03 15:14 * * * @author victor * @version 产品版本信息 2021年02月03日15:14分 victor(victorfm@163.com) 新建 * * 修改记录 * @email victorfm@163.com * @project java_mode * @package com.atguigu.factory.factorymethod.pizzastore */ public abstract class Pizza { protected String name; // 披萨名字 // 准备原材料,不同的pizza是不一样的 // ,因此我们做成一个抽象方法 public abstract void prepare(); // 烘烤 public void bake() { System.out.println(name+\"baking;\"); } // 切片 public void cut() { System.out.println(name+\"cutting;\"); } //打包 public void box() { System.out.println(name+\"boxting;\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } } 主方法 package com.atguigu.factory.factorymethod.pizzastore.order; /** * ClassName: PizzaStore * Description: PizzaStore * Date: 2021-02-03 16:51 * * * @author victor * @version 产品版本信息 2021年02月03日16:51分 victor(victorfm@163.com) 新建 * * 修改记录 * @email victorfm@163.com * @project java_mode * @package com.atguigu.factory.factorymethod.pizzastore.order */ public class PizzaStore { public static void main(String[] args) { // 创建北京口味 各种 Pizza new BJOrderPizza(); /* * * input pizza type: cheese 给北京的奶酪披萨准备原材料! 北京的奶酪披萨baking; 北京的奶酪披萨cutting; 北京的奶酪披萨boxting; * * input pizza type: pepper 北京的胡椒披萨准备原材料! 北京的胡椒披萨baking; 北京的胡椒披萨cutting; 北京的胡椒披萨boxting; * */ // todo 还可以 加上 北京or 伦敦的供用户选择的嗯 // 比如加上location // 创建伦敦口额为的各种披萨 // new LDOrderPizza(); // 这个代码就不写了 // 你永远无法叫醒一个装睡的人 } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-06 22:17:09 "},"45_工厂模式_抽象工厂模式.html":{"url":"45_工厂模式_抽象工厂模式.html","title":"抽象工厂模式","keywords":"","body":"抽象工厂模式抽象工厂模式 基本介绍 抽象工厂模式: 定义了一个Interface用于创建相关或有依赖关系的对象,而无需指明具体的类 抽象工厂模式可以将 简单工厂模式 和 工厂方法模式 进行整合. 从设计层面看,抽象工厂模式就是对简单工厂模式的改进(或者成为进一步的抽象) 将工厂抽象成2层,AbsFactory(抽象工厂)和具体实现的子工厂类. 程序员可以根据创建对象类型使用对应的工厂子类. 这样将单个的简单工厂编程了 工厂簇, 更利于代码的维护和扩展. 说白了 我们可以把这个要创建对象实例的方法做成一个抽象方法,放到一个接口里面,然后让下面的一个工厂子类去实现,然后我们需要哪个工厂就把他们聚合到我们的使用类/客户端 即可 这样一个简单的工厂类就变成了一堆儿工厂类,这样就利于我们 代码的扩展和修改 看一个类图 如果要扩展, 可以这样加一个类 代码演示 pizza BJCheesePizza public class BJCheesePizza extends Pizza { @Override public void prepare() { setName(\"北京的奶酪披萨\"); System.out.println(\"给北京的奶酪披萨准备原材料!\"); } } BJPepperPizza public class BJPepperPizza extends Pizza { @Override public void prepare() { setName(\"北京的胡椒披萨\"); System.out.println(\"北京的胡椒披萨准备原材料!\"); } } LDCheesePizza public class LDCheesePizza extends Pizza { @Override public void prepare() { setName(\"伦敦奶酪披萨!\"); System.out.println(\"给伦敦奶酪披萨准备原材料\"); } } LDPepperPizza public class LDPepperPizza extends Pizza { @Override public void prepare() { setName(\"给伦敦的胡椒披萨\"); System.out.println(\"给伦敦的胡椒披萨准备原材料!\"); } } Pizza public abstract class Pizza { protected String name; // 披萨名字 // 准备原材料,不同的pizza是不一样的 // ,因此我们做成一个抽象方法 public abstract void prepare(); // 烘烤 public void bake() { System.out.println(name+\"baking;\"); } // 切片 public void cut() { System.out.println(name+\"cutting;\"); } //打包 public void box() { System.out.println(name+\"boxting;\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } } order AbsFactory // 一个抽象工厂模式的抽象层(接口) public interface AbsFactory { // 让下面的工厂子类来具体实现 public Pizza createPizza(String orderType); } BJFactory // 这是一个工厂子类 public class BJFactory implements AbsFactory{ @Override public Pizza createPizza(String orderType) { System.out.println(\"使用到的是抽象农场模式i\"); Pizza pizza = null; if (orderType.equals(\"cheese\")) { pizza = new BJCheesePizza(); } else if (orderType.equals(\"pepper\")) { pizza = new BJPepperPizza(); } else { } return pizza; } } LDFactory public class LDFactory implements AbsFactory{ @Override public Pizza createPizza(String orderType) { Pizza pizza = null; if (orderType.equals(\"cheese\")) { pizza = new LDCheesePizza(); } else if (orderType.equals(\"pepper\")) { pizza = new LDPepperPizza(); } else { } return pizza; } } OrderPizza public class OrderPizza { // 聚合 AbsFactory factory; // 构造器 public OrderPizza(AbsFactory factory) { setFactory(factory); } private void setFactory(AbsFactory factory) { // Pizza pizza = null; String orderType = \"\"; // 用户输入 this.factory = factory; do { orderType = getType(); // factory 可能是北京的工厂子类,也可能是伦敦的工厂子类 pizza = factory.createPizza(orderType); if (pizza != null) { pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } else { System.out.println(\"订购失败!\"); break; } } while (true); } // 写一个方法,可以获取客户希望订购的披萨种类 private String getType() { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza type:\"); String str = null; try { str = strin.readLine(); } catch (IOException e) { e.printStackTrace(); } return str; } } PizzaStore package com.atguigu.factory.absfactory.order; /** * ClassName: PizzaStore * Description: PizzaStore * Date: 2021-02-04 9:45 * * * @author victor * @version 产品版本信息 2021年02月04日9:45分 victor(victorfm@163.com) 新建 * * 修改记录 * @email victorfm@163.com * @project java_mode * @package com.atguigu.factory.absfactory.order */ public class PizzaStore { public static void main(String[] args) { System.out.println(); new OrderPizza(new BJFactory()); // 运行 /* input pizza type: cheese 使用到的是抽象农场模式i 给北京的奶酪披萨准备原材料! 北京的奶酪披萨baking; 北京的奶酪披萨cutting; 北京的奶酪披萨boxting; * */ } } 总结 如果你的产品种类很多,那么,你用这个抽象工厂模式更加的灵活的哦 如果你就那么几种产品,嗯,你就老老实实的用简单的工厂模式就够了 要活学活用,不能像玉鼎真人一样,只会死背书就连简单的爬云都不会 抽象工厂模式new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"46_工厂模式_JDK源码分析.html":{"url":"46_工厂模式_JDK源码分析.html","title":"JDK源码分析","keywords":"","body":"工厂模式工厂模式小结工厂模式 JDK-Calendar的源码分析 JDK中的calendar类中,就使用了简单的工厂模式 源码分析+Debug源码+说明 如下图 package com.atguigu.factory.JDK; import java.util.Calendar; public class Factory { public static void main(String[] args) { // getInstance 是Calendar 静态方法 Calendar cal = Calendar.getInstance(); // 注意月份下标从0开始,所以要取月份要+1 System.out.println(\"年:\"+cal.get(Calendar.YEAR)); System.out.println(\"月:\"+cal.get(Calendar.MONTH)+1); System.out.println(\"日:\"+cal.get(Calendar.DAY_OF_MONTH)); System.out.println(\"时:\"+cal.get(Calendar.HOUR_OF_DAY)); System.out.println(\"分:\"+cal.get(Calendar.MINUTE)); System.out.println(\"秒:\"+cal.get(Calendar.SECOND)); } } getInstance里面 /** * Gets a calendar using the default time zone and locale. The * Calendar returned is based on the current time * in the default time zone with the default * {@link Locale.Category#FORMAT FORMAT} locale. * * @return a Calendar. */ public static Calendar getInstance() { return createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT)); } 再往里走 createCalendar private static Calendar createCalendar(TimeZone zone, Locale aLocale) // 这个地方 根据 在创建的时候 传入的值(TimeZone Locale)的不同 来决定 { CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale) .getCalendarProvider(); if (provider != null) { try { return provider.getInstance(zone, aLocale); } catch (IllegalArgumentException iae) { // fall back to the default instantiation } } Calendar cal = null; if (aLocale.hasExtensions()) { String caltype = aLocale.getUnicodeLocaleType(\"ca\"); if (caltype != null) { switch (caltype) { case \"buddhist\": // 这里你看吧,他判断了,他判断了 // 根据不同的情况,来调用不同的方法 cal = new BuddhistCalendar(zone, aLocale); break; case \"japanese\": // 返回对应的实例 cal = new JapaneseImperialCalendar(zone, aLocale); break; case \"gregory\": // 有感兴趣的同学可以再往里面追一下源码 cal = new GregorianCalendar(zone, aLocale); break; } } } if (cal == null) { // If no known calendar type is explicitly specified, // perform the traditional way to create a Calendar: // create a BuddhistCalendar for th_TH locale, // a JapaneseImperialCalendar for ja_JP_JP locale, or // a GregorianCalendar for any other locales. // NOTE: The language, country and variant strings are interned. if (aLocale.getLanguage() == \"th\" && aLocale.getCountry() == \"TH\") { cal = new BuddhistCalendar(zone, aLocale); } else if (aLocale.getVariant() == \"JP\" && aLocale.getLanguage() == \"ja\" && aLocale.getCountry() == \"JP\") { cal = new JapaneseImperialCalendar(zone, aLocale); } else { cal = new GregorianCalendar(zone, aLocale); } } return cal; } 工厂模式小结 工厂模式的意义 将实例化对象代码提取出来,放到一个类中统一管理和维护,达到和主项目的依赖关系的解耦.从而提高项目的扩展和维护性 三种工厂模式(简单工厂模式,工厂方法模式,抽象工厂模式) 设计模式的 依赖抽象 原则 创建对象实例的时候,不要直接new类,而是把这个new类的动作放在一个工厂的方法中,并返回. 也有的书上说,变量不要直接持有具体类的引用 不要让类继承具体类,而是继承抽象类或者实现interface(接口) 不要覆盖基类中已经实现的方法 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-06 22:21:28 "},"49_原型模式_克隆羊.html":{"url":"49_原型模式_克隆羊.html","title":"克隆羊","keywords":"","body":"原型模式原型模式原型模式解决克隆羊 问题原型模式 克隆羊问题 现在有一只羊tom,姓名为: tom,年龄为1,颜色为: 白色,请编写程序创建和tom羊属性完全相同的10只羊.. 实践出真知 最简单的思路 package com.atguigu.prototype; public class Sheep { private String name; private int age; private String color; public Sheep(String name, int age, String color) { this.name = name; this.age = age; this.color = color; } @Override public String toString() { return \"Sheep{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", color='\" + color + '\\'' + '}'; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } } package com.atguigu.prototype; public class Client { public static void main(String[] args) { // 传统的方法 Sheep sheep = new Sheep(\"tom\", 1, \"白色\"); // 用第一次的sheep 的信息去初始化 下一只羊的属性 Sheep sheep2 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep3 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep4 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep5 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep6 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep7 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep8 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep9 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); System.out.println(sheep); System.out.println(sheep2); System.out.println(sheep3); System.out.println(sheep4); System.out.println(sheep5); System.out.println(sheep6); System.out.println(sheep7); System.out.println(sheep8); System.out.println(sheep9); } } ```shell script Sheep{name='tom', age=1, color='白色'} Sheep{name='tom', age=1, color='白色'} Sheep{name='tom', age=1, color='白色'} Sheep{name='tom', age=1, color='白色'} Sheep{name='tom', age=1, color='白色'} Sheep{name='tom', age=1, color='白色'} Sheep{name='tom', age=1, color='白色'} Sheep{name='tom', age=1, color='白色'} Sheep{name='tom', age=1, color='白色'} Process finished with exit code 0 ``` 传统方式解决克隆羊问题 传统的方式的优缺点 优点是比较好理解,简单易操作. 在创建新的对象的时,总是需要重新获取原始对象的属性,如果创建的对象比较复杂时,效率较低 总是需要重新初始化对象,而不是动态地获得对象运行时的状态,不够灵活 改进的思路分析 思路 : Java中Object类是所有类的根类,Object类提供了一个clone()方法,该方法可以将一个Java对象复制一份,但是需要实现clone的Java类必须要实现一个接口Cloneable,该接口表示该类能够复制且具有复制的能力 => 原型模式 原型模式 基本介绍 原型模式(Prototype模式是指:用原型实例指定创建对象的种类,并且通过拷贝这些原型,创建新的对象) 原型模式是一种创建型设计模式,允许一个对象再创建另外一个可定制的对象,无需知道如何创建的细节 工作原理是:通过将一个原型对象传给那个要发动创建的对象,这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建,即: 对象.clone() 形象的理解: 孙大圣拔出猴毛,变出其他猴子 原型模式 - 原理结构图(UML类图) 原理结构图说明 Prototype:原型类,声明一个克隆自己的接口 ConcretePrototype: 具体的原型类,实现一个克隆自己的操作 Client 让一个原型对象克隆自己,从而创建一个新的对象(属性一样) 原型模式解决克隆羊 问题 原型模式解决克隆羊问题的应用实例 使用 原型模式 改进传统方式,让程序具有更高的效率和扩展性 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 21:56:03 "},"51_原型模式_源码分析.html":{"url":"51_原型模式_源码分析.html","title":"Spring源码分析","keywords":"","body":"原型模式 Spring源码原型模式 Spring源码 Spring中原型bean的创建,就是原型模式的应用 代码分析+Debug源码 beans.xml new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-07 17:45:45 "},"52_原型模式_浅拷贝.html":{"url":"52_原型模式_浅拷贝.html","title":"浅拷贝","keywords":"","body":"原型模式深入讨论 - 浅拷贝和深拷贝浅拷贝的介绍浅拷贝 实践1浅拷贝 实践2原型模式 深入讨论 - 浅拷贝和深拷贝 浅拷贝的介绍 相关链接:Python3中深拷贝与浅拷贝 对于数据类型是基本数据类型的成员变量,浅拷贝会直接进行值传递,也就是将该属性值复制一份给新的对象 对于数据类型是 引用数据类型 的成员变量,比如说这个成员变量是某个数组,某个类的对象等,那么浅拷贝会进行引用传递,也就是只是将该成员变量的引用值(内存地址)复制一份给新的对象.因为实际上两个对象的该成员变量都指向了同一个实例(内存地址).在这种情况下,在一个对象中修改该成员变量会影响到另一个对象的改成员变量的值. 前面我们克隆羊就是浅拷贝 浅拷贝是使用默认的clone()方法来实现的 sheep = (Sheep) super.clone(); 浅拷贝 实践1 Sheep package com.atguigu.prototype.improve; public class Sheep implements Cloneable { private String name; private int age; private String color; private String address = \"蒙古样\"; public Sheep(String name, int age, String color) { this.name = name; this.age = age; this.color = color; } @Override public String toString() { return \"Sheep{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", color='\" + color + '\\'' + \", address='\" + address + '\\'' + '}'; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } // 克隆该实例,使用默认的克隆方法来完成 @Override protected Object clone() { Sheep sheep = null; // try { sheep = (Sheep) super.clone(); } catch (CloneNotSupportedException e) { System.out.println(e.getMessage()); } return sheep; } } Clinet package com.atguigu.prototype.improve; public class Clinet { public static void main(String[] args) { // 原型模式完成 对象的创建 Sheep sheep = new Sheep(\"tom\", 1, \"白色\"); Sheep sheep2 = (Sheep) sheep.clone(); // 克隆 Sheep sheep3 = (Sheep) sheep.clone(); // 克隆 Sheep sheep4 = (Sheep) sheep.clone(); // 克隆 System.out.println(sheep); System.out.println(sheep2); System.out.println(sheep3); System.out.println(sheep4); /* * Sheep{name='tom', age=1, color='白色', address='蒙古样'} Sheep{name='tom', age=1, color='白色', address='蒙古样'} Sheep{name='tom', age=1, color='白色', address='蒙古样'} Sheep{name='tom', age=1, color='白色', address='蒙古样'} Process finished with exit code 0 * */ } } 浅拷贝 实践2 Sheep package com.atguigu.prototype.improve2; public class Sheep implements Cloneable { private String name; private int age; private String color; private String address = \"蒙古样\"; public Sheep friend; // 是对象 ,克隆的时候会怎么处理 public Sheep(String name, int age, String color) { this.name = name; this.age = age; this.color = color; } @Override public String toString() { return \"Sheep{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", color='\" + color + '\\'' + \", address='\" + address + '\\'' + \", friend=\" + friend + '}'; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public Sheep getFriend() { return friend; } public void setFriend(Sheep friend) { this.friend = friend; } // 克隆该实例,使用默认的克隆方法来完成 @Override protected Object clone() { Sheep sheep = null; // try { sheep = (Sheep) super.clone(); } catch (CloneNotSupportedException e) { System.out.println(e.getMessage()); } return sheep; } } Clinet package com.atguigu.prototype.improve2; public class Clinet { public static void main(String[] args) { // 原型模式完成 对象的创建 Sheep sheep = new Sheep(\"tom\", 1, \"白色\"); sheep.friend = new Sheep(\"jack\", 3, \"黑色\"); Sheep sheep2 = (Sheep)sheep.clone(); // 克隆 System.out.println(\"sheep=\"+sheep); System.out.println(\"sheep.friend=\"+sheep.friend.hashCode()); System.out.println(\"sheep2=\"+sheep2); System.out.println(\"sheep2.friend=\"+sheep2.friend.hashCode()); /* * * sheep=Sheep{name='tom', age=1, color='白色', address='蒙古样', friend=Sheep{name='jack', age=3, color='黑色', address='蒙古样', friend=null}} sheep.friend=356573597 sheep2=Sheep{name='tom', age=1, color='白色', address='蒙古样', friend=Sheep{name='jack', age=3, color='黑色', address='蒙古样', friend=null}} sheep2.friend=356573597 Process finished with exit code 0 * */ // 这不就是相当于没克隆成么,浅拷贝的 } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-06 22:21:28 "},"54_原型模式_深拷贝.html":{"url":"54_原型模式_深拷贝.html","title":"深拷贝","keywords":"","body":"深拷贝的介绍深拷贝实践第一种第二种原型模式的注意事项和细节深拷贝的介绍 复制对象的所有基本数据类型的成员变量值 为所有引用数据类型的成员变量申请存储空间,并复制每个引用数据类型成员变量所引用的对象,直到该对象可达的所有对象.也就是说,对象进行深拷贝要对整个对象进行拷贝 深拷贝实现方式1: 重写clone()方法实现深拷贝 深拷贝实现方式2: 通过对象序列化实现深拷贝 深拷贝实践 第一种 DeepCloneableTarget package com.atguigu.prototype.deepclone; import java.io.Serializable; public class DeepCloneableTarget implements Serializable,Cloneable { /* * * */ private static final long serialVersionUID = 1L; private String cloneName; private String cloneClass; public DeepCloneableTarget(String cloneName, String cloneClass) { this.cloneName = cloneName; this.cloneClass = cloneClass; } public DeepCloneableTarget() { super(); } // 因为该类的属性都是String, 因此我们这里使用默认的clone方法完成即可 @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } DeepCloneableTarget package com.atguigu.prototype.deepclone; import java.io.Serializable; public class DeepProtoType implements Serializable,Cloneable { public String name; // String 属性 public DeepCloneableTarget deepCloneableTarget; // 引用类型属性 public DeepProtoType() { super(); } // 深拷贝 -- 方式1 使用clone方法 @Override protected Object clone() throws CloneNotSupportedException { Object deep = null; // 这里完成对基本数据类型(属性) 和String 的克隆 deep = super.clone(); // 对引用类型的属性,进行单独处理 // 先创建,转换子类类型 DeepProtoType deepProtoType = (DeepProtoType) deep; deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone(); return deepProtoType; } /* * 问题: 这样不会递归拷贝么? * */ } Clinet package com.atguigu.prototype.deepclone; public class Clinet { public static void main(String[] args) throws CloneNotSupportedException { DeepProtoType p = new DeepProtoType(); p.name = \"松江\"; p.deepCloneableTarget = new DeepCloneableTarget(\"大牛\", \"小牛\"); //方式1 完成深拷贝 DeepProtoType p2 = (DeepProtoType) p.clone(); System.out.println(p); System.out.println(p.name); System.out.println(p.deepCloneableTarget); System.out.println(p2); System.out.println(p2.name); System.out.println(p2.deepCloneableTarget); /* com.atguigu.prototype.deepclone.DeepProtoType@1540e19d 松江 com.atguigu.prototype.deepclone.DeepCloneableTarget@677327b6 com.atguigu.prototype.deepclone.DeepProtoType@14ae5a5 松江 com.atguigu.prototype.deepclone.DeepCloneableTarget@7f31245a Process finished with exit code 0 * */ /* * todo 这种方式 就是可以 实现深拷贝 * 说白了就是,在里面 提取出来属性对象, 单独进行拷贝 * */ } } 第二种 DeepProtoType package com.atguigu.prototype.deepclone; import java.io.*; public class DeepProtoType implements Serializable,Cloneable { public String name; // String 属性 public DeepCloneableTarget deepCloneableTarget; // 引用类型属性 public DeepProtoType() { super(); } // 深拷贝 -- 方式2 通过对象的序列化实现(推荐) public Object deepClone(){ // 创建流对象 ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; ByteArrayInputStream bis = null; ObjectInputStream ois = null; try { // 序列化 bos = new ByteArrayOutputStream(); // 吧这个字节数组输出流换成了对象输出流 oos = new ObjectOutputStream(bos); // 把当前这个对象以对象流的方式输出 oos.writeObject(this); // 反序列化 bis = new ByteArrayInputStream(bos.toByteArray()); // 读进来就相当于把我们这个对象进行了克隆 ois = new ObjectInputStream(bis); // ois就读到了原来序列化出去的这个对象 DeepProtoType copyObj = (DeepProtoType)ois.readObject(); // 我用序列化这个特点,把你关联的引用的输出出去,读回来后就相当云拷贝了 return copyObj; // 我们这波操作就是充分利用我们的序列化和饭序列化, // 把当前对象以对象流的方式输出和读回来,就不用一个一个来搞了 } catch (IOException e) { e.printStackTrace(); return null; } catch (ClassNotFoundException e) { e.printStackTrace(); } finally { // 关闭已经打开的流 try { bos.close(); oos.close(); bis.close(); ois.close(); } catch (IOException e) { e.printStackTrace(); System.out.println(e.getMessage()); } } return null; } } DeepCloneableTarget package com.atguigu.prototype.deepclone; import java.io.Serializable; public class DeepCloneableTarget implements Serializable,Cloneable { /* * * */ private static final long serialVersionUID = 1L; private String cloneName; private String cloneClass; public DeepCloneableTarget(String cloneName, String cloneClass) { this.cloneName = cloneName; this.cloneClass = cloneClass; } public DeepCloneableTarget() { super(); } // 因为该类的属性都是String, 因此我们这里使用默认的clone方法完成即可 @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } Clinet package com.atguigu.prototype.deepclone; public class Clinet { public static void main(String[] args) throws CloneNotSupportedException { DeepProtoType p = new DeepProtoType(); p.name = \"松江\"; p.deepCloneableTarget = new DeepCloneableTarget(\"大牛\", \"小牛\"); // 方式2 完成深拷贝 DeepProtoType p2 = (DeepProtoType) p.deepClone(); System.out.println(p); System.out.println(p.name); System.out.println(p.deepCloneableTarget); System.out.println(p2); System.out.println(p2.name); System.out.println(p2.deepCloneableTarget); /* com.atguigu.prototype.deepclone.DeepProtoType@330bedb4 松江 com.atguigu.prototype.deepclone.DeepCloneableTarget@2503dbd3 com.atguigu.prototype.deepclone.DeepProtoType@4f3f5b24 松江 com.atguigu.prototype.deepclone.DeepCloneableTarget@15aeb7ab Process finished with exit code 0 * */ // 推荐第2中 } } 原型模式的注意事项和细节 创建新的对象比较复杂的时候,可以利用原型模式简化对象的创建过程,同时也能够提高效率 不用重新初始化对象,而是动态地获得对象运行时的状态 如果原始对象发生变化(增加或者减少属性),其他克隆对象的也会发生相应的编号,无需修改代码 在实现深克隆的时候可能需要比较复杂的代码 缺点: 需要为每一个类配备一个克隆方法,这对全新的类来说,不是很难,但是对已经有的类进行改造的时候,需要修改其源码,这就违背了ocp开放封闭原则,这点要注意一下. 原型模式new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"55_建造者模式_盖房子.html":{"url":"55_建造者模式_盖房子.html","title":"盖房子","keywords":"","body":"建造者模式建造者模式 盖房子项目需求 需要建房子: 这一个过程为打桩,砌墙,封顶 房子有各种各样的,比如普通房,高楼,别墅,各种房子的过程虽然一样,但是要求不要相同的 编写程序完成需求 思路图 package com.atguigu.builder; public abstract class AbstractHouse { // 打地基 public abstract void buildBasic(); // 砌墙 public abstract void buildWalls(); // 封顶 public abstract void roofed(); //我们这个盖房子是有顺序的, // 所以再封装一层, public void build() { buildBasic(); buildWalls(); roofed(); } } package com.atguigu.builder; public class CommonHouse extends AbstractHouse { @Override public void buildBasic() { System.out.println(\"-----------\"); System.out.println(\"普通房子打地基\"); } @Override public void buildWalls() { System.out.println(\"-----------\"); System.out.println(\"普通房子砌墙\"); } @Override public void roofed() { System.out.println(\"-----------\"); System.out.println(\"普通房子封顶\"); } } 好了,现在写一个主方法 package com.atguigu.builder; public class Clinet { public static void main(String[] args) { CommonHouse commonHouse = new CommonHouse(); commonHouse.build(); /* ----------- 普通房子打地基 ----------- 普通房子砌墙 ----------- 普通房子封顶 * */ } } 现在房子盖好了,他有什么问题么? 传统方式解决盖房子需求问题分析 优点是比较好理解,简单易操作 设计的程序结构,过于简单,没有设计缓存层对象,程序的扩展和维护不好.也就是说,这种设计方案,把产品(即: 房子)和创建产品的过程(即: 建房子流程) 封装在了一起,耦合性质增强了 解决方案: 将产品和产品的建造过程解耦 ==> 建造者模式 应该叫做包工头模式 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"56_建造者模式_4个角色.html":{"url":"56_建造者模式_4个角色.html","title":"4个角色","keywords":"","body":"建造者模式基本介绍建造者模式基本介绍 概念 建造者模式(Builder Pattern) 又叫生成器模式,是一种对象构建模式. 它可以将复杂对象的构建过程抽象出来(抽象类别),使这个抽象过程的不同实现方法可以构造出不同表现(属性)的对象. 建造者模式 是一步一步创建一个复杂的对象,他允许用户只通过指定复杂对象的类型和内容就可以构建它们,用户不需要知道内部的具体构建细节. python 中的生成器? 菜鸟 建造者模式的4个角色 Product(产品角色): 一个具体的产品对象 Builder(抽象建造者): 创建一个Product对象的各个部件指定的接口 ConcreteBuilder(具体建造者): 实现接口,构建和装配各个部件. Director(指挥者): 构建一个使用Builder接口的对象.它主要是用于创建一个复杂对象.他主要有2个作用, 一是: 隔离了客户与对象的生产过程, 二是: 负责控制产品对象的生产过程 建造者模式原理类图 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-04 18:59:17 "},"57_建造者模式_代码演示.html":{"url":"57_建造者模式_代码演示.html","title":"代码演示","keywords":"","body":"代码实践代码实践 房子 package com.atguigu.builder.improve; // 产品 => Product public class House { private String baise; private String wall; private String roofed; public String getBaise() { return baise; } public void setBaise(String baise) { this.baise = baise; } public String getWall() { return wall; } public void setWall(String wall) { this.wall = wall; } public String getRoofed() { return roofed; } public void setRoofed(String roofed) { this.roofed = roofed; } } 抽象建造者 package com.atguigu.builder.improve; // 抽象的建造者 public abstract class HouseBuilder { protected House house = new House(); // 将建造的流程写好,抽象的方法 public abstract void buildBasic(); public abstract void buildWalls(); public abstract void roofed(); /** * 建造房子好,将产品(房子)返回 * @return */ public House buildHouse() { return house; } } 矮楼 package com.atguigu.builder.improve; /** * 抽象 */ public class CommonHouse extends HouseBuilder{ @Override public void buildBasic() { System.out.println(\"普通的房子地基5米\"); } @Override public void buildWalls() { System.out.println(\"普通房子砌墙10cm\"); } @Override public void roofed() { System.out.println(\"普通房子屋顶盖上了\"); } } 高楼 package com.atguigu.builder.improve; public class HighBuilding extends HouseBuilder{ @Override public void buildBasic() { System.out.println(\"高楼的地基98米\"); } @Override public void buildWalls() { System.out.println(\"高楼的墙20cm\"); } @Override public void roofed() { System.out.println(\"高楼的屋顶透明的\"); } } HouseDirector package com.atguigu.builder.improve; // 指挥者,去指定制定流程,返回产品 public class HouseDirector { // 聚合进来 HouseBuilder houseBuilder = null; // 构造器传入 public HouseDirector(HouseBuilder houseBuilder) { this.houseBuilder = houseBuilder; } // 通过setter方法传入 public void setHouseBuilder(HouseBuilder houseBuilder) { this.houseBuilder = houseBuilder; } // 如何处理建造房子的流程 // 交给了指挥者 public House constructHouse() { // 先打地基 houseBuilder.buildBasic(); // 在墙 houseBuilder.buildWalls(); // 顶 houseBuilder.roofed(); // 返回 return houseBuilder.buildHouse(); } } 主方法(客户端)调用 package com.atguigu.builder.improve; public class Clinet { public static void main(String[] args) { System.out.println(); // 盖普通票房子 CommonHouse commonHouse = new CommonHouse(); // 准备创建房子的指挥者 HouseDirector houseDirector = new HouseDirector(commonHouse); // 完成盖房子,返回产品(房子 House house = houseDirector.constructHouse(); System.out.println(house); /* out 普通的房子地基5米 普通房子砌墙10cm 普通房子屋顶盖上了 com.atguigu.builder.improve.House@1540e19d * */ } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-09 20:58:31 "},"58_建造者模式_源码分析.html":{"url":"58_建造者模式_源码分析.html","title":"StringBuilder源码","keywords":"","body":"建造者模式建造者模式 * Unless otherwise noted, passing a {@code null} argument to a constructor * or method in this class will cause a {@link NullPointerException} to be * thrown. * * @author Michael McCloskey * @see java.lang.StringBuffer * @see java.lang.String * @since 1.5 */ public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence { /** use serialVersionUID for interoperability */ static final long serialVersionUID = 4383685877147921099L; /** * Constructs a string builder with no characters in it and an * initial capacity of 16 characters. */ public StringBuilder() { super(16); } /** * Constructs a string builder with no characters in it and an * initial capacity specified by the {@code capacity} argument. * * @param capacity the initial capacity. * @throws NegativeArraySizeException if the {@code capacity} * argument is less than {@code 0}. */ public StringBuilder(int capacity) { super(capacity); } 追进去 * thrown. * * @author Michael McCloskey * @author Martin Buchholz * @author Ulf Zibis * @since 1.5 */ abstract class AbstractStringBuilder implements Appendable, CharSequence { /** * The value is used for character storage. */ char[] value; /** * The count is the number of characters used. */ int count; /** * This no-arg constructor is necessary for serialization of subclasses. */ AbstractStringBuilder() { } 我们在查看源码的时候,有可能他在使用的时候,设计模式的思想很相似,但是有可能不完全是一样的,不能完全符合类图中的 源码使用者并不知道他在使用这个设计模式,所以嗯 建造者模式在JDK的应用和源码分析 源码中建造者角色分析 Appendable接口定义了多个append方法(抽象方法),即Appendable为抽象建造者,定义了抽象方法,他其实就已经是一个抽象建造者了 有建造者就肯定会有具体的建造者实现类,但是-> AbstractStringBuilder 实现了Appendable接口方法,这里的AbstractStringBuilder 已经是建造者了,只是不能实例化了 哈哈哈,写jdk这个哥们他太牛了,他已经在无形中写出了这种设计模式,只是他自己不知道而已,这种设计模式的总结是在以后才提出来的,所以他不已经很标准嗯 StringBuilder即充当了指挥者角色,同时充当了建造者模式,建造方法的实现是由AbstractStringBuilder 完成,而我们StringBuilder只是继承了AbstractStringBuilder 人家写源码的时候,没有几个人设计模式,有可能只是你这么认为的,作者不是这么想的呢还兴许 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-07 17:45:45 "},"59_建造者模式_内容梳理.html":{"url":"59_建造者模式_内容梳理.html","title":"内容梳理","keywords":"","body":"建造者模式小结建造者模式的注意事项和细节建造者模式小结 建造者模式的注意事项和细节 客户端(使用程序)不必知道产品内部组成的细节,将产品本身与产品的创建过程解耦,使得相同的创建过程可以创建不同的产品对象. 每一个具体建造者都相对独立,而与其他的具体建造者无关,因此可以很方便地替换具体建造者或增加新的具体建造者,用户使用不同的具体建造者即可得到不同的产品对象 可以更加精细地控制产品的创建过程,将复杂产品的创建步骤分解在不同的方法中,使得创建过程更加清晰,也更方便使用程序来控制创建过程. 增加新的具体建造者无需修改原有类库的代码,指挥者类针对抽象建造者类编程,系统扩展方便,符合 \"开闭原则\". 建造者模式所创建的产品一般具有较多的共同点,其组成部分相似,如果产品之间的差异性很大,则不适合使用建造者模式,因此其使用范围受到一定的限制. 如果产品的内部变化复杂,可能会导致需要定义很多具体建造者类来实现这种变化,导致系统变得庞大,因此在这种情况下,要考虑是否选择建造者模式. 抽象工厂模式 VS 建造者模式 抽象工厂模式实现对产品家族的创建,一个产品家族是这样的一系列产品: 具有不同分类维度的产品组合,采用抽象工厂米模式不需要关心构建过程,只关心什么产品由什么工厂生产即可.而建造者模式则是要求按照指定的蓝图建造产品,它的主要目的是通过组装零配件而产生一个新产品. 一句话,抽象工厂,制作的成品,不满足就换厂子,建造管的是如何建造,制造顺序 建造者模式 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"60_适配器模式_工作原理.html":{"url":"60_适配器模式_工作原理.html","title":"工作原理","keywords":"","body":"适配器模式适配器模式 先看一个案例 显示生活中的适配器的例子 泰国插座用的是2孔的(欧标),可以买个 多功能转换插头 (适配器),这样就可以使用了 转接线 适配器模式基本介绍 适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示,主要目的是兼容性,让原来因接口不匹配不能一起工作的两个类可以协同工作.其别名为 包装器(Wrapper) 适配器模式属于结构型模式(并没有产生新的对象) 主要分为3类: 类适配器模式,对象适配器模式,接口适配器模式 适配器工作原理 适配器模式: 将一个类的接口转换成另一种接口,让 原本接口不兼容的类可以 兼容 从用户的角度看不到适配者,是解耦的 用户收到反馈结果,感觉只是和目标接口交互,如图 被适配者就是 泰国的插口 适配器就是转换头 可用的笔记本电源线就是 使用者 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-06 22:21:28 "},"61_类适配器_电压问题.html":{"url":"61_类适配器_电压问题.html","title":"类适配器","keywords":"","body":"类适配器模式 类适配器模式介绍 基本介绍: Adapter类,通过继承src类,实现dst类接口, 完成 src->dst的适配. 类适配器模式应用实例 应用实例说明 以生活中充电器的例子来讲解适配器,充电器本身相当于Adapter, 220V交流电相当于src(即被适配者),我们的目的dst(即目标)是5V直流电 思路分析图解 类图 代码实践 被适配的类 package com.atguigu.adapter; // 被适配的类 public class Voltage220V { public int output220V() { int src = 220; System.out.println(\"电压\"+src+\"福特\"); return src; } } 适配接口 package com.atguigu.adapter; // 适配接口 public interface IVoltage5V { public int output5V(); } 适配器 package com.atguigu.adapter; public class VoltageAdapter extends Voltage220V implements IVoltage5V { @Override public int output5V() { // 获取220V电压 int srcV = output220V(); // 转换成为5V int dstV = srcV / 44; return dstV; } } 手机 package com.atguigu.adapter; public class Phone { // 充电 public void charging(IVoltage5V iVoltage5V) { if (iVoltage5V.output5V() == 5) { System.out.println(\"电压为5V,可以充电~~~\"); } else if (iVoltage5V.output5V() > 5) { System.out.println(\"电压大于5V,白扯充电~~~\"); } } } 客户端 package com.atguigu.adapter; public class Client { public static void main(String[] args) { System.out.println(\"--类适配器模式--\"); Phone phone = new Phone(); phone.charging(new VoltageAdapter()); /* --类适配器模式-- 电压220福特 电压为5V,可以充电~~~ Process finished with exit code 0 * */ } } 类适配器模式注意事项和细节 Java是单继承机制,所以类适配器需要继承src类这一点算是一个缺点,因为这样求dst必须是接口,有一定的局限性(他只能继承一个,另一个不能继承,只能实现,接口) src类的方法在Adapter中都会暴漏出来,也增加了使用成本 由于其继承了src类,所以他可以根据需求重写src类的方法,使得Adapter的灵活性增强了 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-06 22:21:28 "},"62_对象适配器_电压问题.html":{"url":"62_对象适配器_电压问题.html","title":"对象适配器","keywords":"","body":"对象适配器模式对象适配器模式介绍对象适配器模式应用实例实践出真知对象适配器模式注意事项和细节一句话对象适配器模式 对象适配器模式介绍 基本思路和类的适配器模式相同,只是将Adapter类做修改,不是继承src类,而是持有src类的实例,以解决兼容性的问题. 即: 持有src类,实现dst接口,完成 src->dst的适配 根据 \"合成复用原则\" ,在系统中尽量使用 关联 关系来替代 继承 关系. 对象适配器模式是适配器模式常用的一种 对象适配器模式应用实例 应用实例说明 以生活中的充电器的例子来讲解适配器,充电器本身相当于Adapter,220V交流电相当于src(即被适配者),我们的目的地dst(即目标)是5V直直流电,使用 对象适配器模式 完成 思路分析(类图): 只需要修改适配器即可,如下: 实践出真知 在原来的基础上进行改动 适配接口// 接口不用动 package com.atguigu.adapter.objectadapter; // 适配接口// 接口不用动 public interface IVoltage5V { public int output5V(); } 被适配的类也不用动 package com.atguigu.adapter.objectadapter; // 被适配的类 public class Voltage220V { // 这个不用变 public int output220V() { int src = 220; System.out.println(\"电压\"+src+\"福特\"); return src; } } VoltageAdapter适配器不在继承220V了,而是通过聚合的关系传递进来 package com.atguigu.adapter.objectadapter; public class VoltageAdapter implements IVoltage5V { // 我家一个属性 private Voltage220V voltage220V; // 构造器 public VoltageAdapter(Voltage220V voltage220V) { // 通过构造器,传入一个Voltage220V实例 // 关联关系的聚合关系 this.voltage220V = voltage220V; } @Override public int output5V() { // int dst = 0; if (null != voltage220V) { // 获取220V电压 int src = voltage220V.output220V(); // System.out.println(\"使用对象适配器记性转换,~\"); dst = src / 44; System.out.println(\"适配完成,输出的电压为=\"+dst); } return dst; } } 执行 package com.atguigu.adapter.objectadapter; public class Client { public static void main(String[] args) { System.out.println(\"--对象适配器模式--\"); com.atguigu.adapter.objectadapter.Phone phone = new Phone(); phone.charging(new VoltageAdapter(new Voltage220V())); /* --对象适配器模式-- 电压220福特 使用对象适配器记性转换,~ 适配完成,输出的电压为=5 电压为5V,可以充电~~~ * */ } } 通过使用这个合成复用原则 来实现了由继承变成了聚合的关系 对象适配器模式注意事项和细节 对象适配器和类适配器其实算是同一种思想,只不过实现的方式不同而已 根据合成复用原则,使用组合替代继承,所以他解决了类适配器必须继承src的局限性问题,也不再要求dst必须是街口友. 使用成本更低,更加的灵活 一句话 比如这个220V改了,改成了330V,你只需要改这个适配器,整个项目就能跑起来了又 优雅 的 coding~ \"物是人非事事休，欲语泪先流\" new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-06 22:21:28 "},"63_接口适配器_电压问题.html":{"url":"63_接口适配器_电压问题.html","title":"接口适配器","keywords":"","body":"接口适配器模式接口适配器模式介绍接口适配器模式应用实例程序类图提问一句话接口适配器模式 接口适配器模式介绍 一些书上说: 适配器模式(Default Adapter Pattern)或缺省适配器模式 当不需要全部实现接口提供的方法时,可先设计一个抽象类实现接口,并为该接口中每个方法提供一个默认实现(空方法),那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求 适用于一个接口不想使用其所有的方法的情况 接口适配器模式应用实例 Android中的属性动画ValueAnimator类可以通过addListener(AnimatorListener listener)方法添加监听器,那么常规写法如右: 有时候我们不想上线 Animator.AnimatorListener接口的全部方法,我们只想监听onAnimationStart,我们会如下写 ![](./img/QQ截图20210205091817.png) 我只是想要实现onAnimationStart方法 其他的默认实现了,我需要关心 AnimatorListenerAdapter类,就是一个接口适配器,代码如右图: 它空实现了Animator.AnimatorListener类(src)的所有方法. AnimatorListener是一个接口 我现在有一个需求,就是这个适配器里面的方法,我有的想使用,有的不想使用,那么看我下一步操作 程序里的匿名内部类就是Listener,具体实现类 程序类图 提问 都实现了还叫抽象,我学了个假设计模式 package com.atguigu.adapter.interfaceadapter; public interface Interface4 { public void m1(); public void m2(); public void m3(); public void m4(); } package com.atguigu.adapter.interfaceadapter; // 在AbsAdapter里面将Interface4的方法进行默认实现 public class AbsAdapter implements Interface4{ // 默认实现 public void m1(){} public void m2(){} public void m3(){} public void m4(){} } package com.atguigu.adapter.interfaceadapter; public class Client { public static void main(String[] args) { // 接口适配,我这里想要用哪个就用哪个 AbsAdapter absAdapter = new AbsAdapter(){ // 只需要去覆盖我们需要使用 接口方法 @Override public void m1() { System.out.println(\"使用了m1的方法\"); } }; absAdapter.m1(); /* 使用了m1的方法 Process finished with exit code 0 * */ } } 一句话 说白了就是,不管你实不实现,我先都进行空实现,你要是想实现,你在实现我也管不着 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-06 22:21:28 "},"64_适配器模式_源码分析.html":{"url":"64_适配器模式_源码分析.html","title":"源码应用","keywords":"","body":"适配器模式_SpringMVC框架应用的源码分析适配器模式_SpringMVC框架应用的源码分析 SpringMVC中的HandlerAdapter ,就是使用了适配器模式 SpringMVC处理请求的流程回顾 使用HandlerAdapter的原因分析: 可以看到处理器的类型不同,有 多重实现方式,那么调用方式就不是确定 的,如果须臾奥直接调用Controller方法,需要调用的时候就得不断是使用if else 来进行判断是哪一种子类然后执行.那么如果后面要扩展Controller,就得修改原来的代码,这样违背了OCP原则. 动手写SpringMVC通过 适配器设计模式 获取到对应的 Controller的源码 说明: Spring定义了一个适配接口,使得每一种Controller有一种对应的适配器实现类 适配器代替Controller执行响应的方法 扩展Controller时,只需要增加一个适配器类就完成了SpringMVC的扩展了, 这就是设计模式的power 类图 适配器模式的注意事项和细节 三种命名方式,是根据src是以怎样的形式给到Adapter(在Adapter里的形式)来命名的 类适配器: 以类给到, 在Adapter里,就是src当做类,继承 对象适配器: 以对象给到, 在Adapter里,就是src当做对象,持有(聚合) 接口适配器: 以接口给到, 在Adapt2er里,就是src当做接口,实现 Adapter模式最大的作用还是将原本,不兼容的接口融合在一起工作. 实际开发中,实现起来不拘泥与我们讲解的三种经典形式 适配器模式new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"65_桥接模式_手机问题.html":{"url":"65_桥接模式_手机问题.html","title":"手机问题","keywords":"","body":"手机操作问题手机操作问题 现在对不同手机类型的不同品牌实现操作编程(比如: 开机,关机,上网,打电话等等) 传统方式类图 传统方案解决手机操作问题分析 扩展性(问题),类爆炸,如果我们再增加手机的样式(旋转式),就需要增加各个品牌手机的类,同样如果我们增加一个手机品牌,也要在各个手机样式类下增加. 违反了 单一职责原则 ,当我们增加手机样式时,要同时增加所有品牌的手机,这样增加了代码维护成本 解决方案-使用桥接模式 类图 代码实践 package com.atguigu.bridge; public interface Brand { public void open(); public void close(); public void call(); } package com.atguigu.bridge; public class Vivo implements Brand{ @Override public void open() { System.out.println(\"vivo手机开机\"); } @Override public void close() { System.out.println(\"vivo shoyji关机\"); } @Override public void call() { System.out.println(\"vivo手机打电话!\"); } } package com.atguigu.bridge; public class XiaoMi implements Brand{ @Override public void open() { System.out.println(\"小米手机开机\"); } @Override public void close() { System.out.println(\"xiaomi shoyji关机\"); } @Override public void call() { System.out.println(\"小米手机打电话!\"); } } package com.atguigu.bridge; public abstract class Phone { // 组合品牌 private Brand brand; public Phone(Brand brand) { super(); this.brand = brand; } protected void open() { this.brand.open(); } protected void close() { this.brand.close(); } protected void call() { this.brand.call(); } } package com.atguigu.bridge; // 折叠是手机类,继承 抽象类Phone public class FoldedPhone extends Phone{ // 构造器 public FoldedPhone(Brand brand) { // 初始化 super(brand); } @Override protected void open() { super.open(); System.out.println(\"打开折叠样式手机\"); } @Override protected void close() { super.close(); System.out.println(\"关闭折叠样式手机\"); } @Override protected void call() { super.call(); System.out.println(\"折叠样式手机打电话\"); } } package com.atguigu.bridge; public class Client { public static void main(String[] args) { // 获取折叠式手机(样式 + 品牌 Phone phone1 = new FoldedPhone(new XiaoMi()); phone1.open(); phone1.call(); phone1.close(); System.out.println(\"-----------\"); Phone phone2 = new FoldedPhone(new Vivo()); phone2.open(); phone2.call(); phone2.close(); /* 小米手机开机 打开折叠样式手机 小米手机打电话! 折叠样式手机打电话 xiaomi shoyji关机 关闭折叠样式手机 ----------- vivo手机开机 打开折叠样式手机 vivo手机打电话! 折叠样式手机打电话 vivo shoyji关机 关闭折叠样式手机 Process finished with exit code 0 * */ } } 扩展一个纸板的手机 package com.atguigu.bridge; public class UpRightPhone extends Phone{ // 构造器 public UpRightPhone(Brand brand) { super(brand); } @Override protected void open() { super.open(); System.out.println(\"打开直板样式手机\"); } @Override protected void close() { super.close(); System.out.println(\"关闭直板样式手机\"); } @Override protected void call() { super.call(); System.out.println(\"直板样式手机打电话\"); } } package com.atguigu.bridge; public class Client { public static void main(String[] args) { // 获取折叠式手机(样式 + 品牌 Phone phone1 = new FoldedPhone(new XiaoMi()); phone1.open(); phone1.call(); phone1.close(); System.out.println(\"-----------\"); Phone phone2 = new UpRightPhone(new Vivo()); phone2.open(); phone2.call(); phone2.close(); /* 小米手机开机 打开折叠样式手机 小米手机打电话! 折叠样式手机打电话 xiaomi shoyji关机 关闭折叠样式手机 ----------- vivo手机开机 打开直板样式手机 vivo手机打电话! 直板样式手机打电话 vivo shoyji关机 关闭直板样式手机 Process finished with exit code 0 * */ } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-06 22:21:28 "},"66_桥接模式_源码剖析.html":{"url":"66_桥接模式_源码剖析.html","title":"源码剖析","keywords":"","body":"桥接模式在JDBC的源码剖析桥接模式在JDBC的源码剖析 画个类图 /** * Attempts to establish a connection to the given database URL. * The DriverManager attempts to select an appropriate driver from * the set of registered JDBC drivers. * * Note: If the {@code user} or {@code password} property are * also specified as part of the {@code url}, it is * implementation-defined as to which value will take precedence. * For maximum portability, an application should only specify a * property once. * * @param url a database url of the form * jdbc:subprotocol:subname * @param user the database user on whose behalf the connection is being * made * @param password the user's password * @return a connection to the URL * @exception SQLException if a database access error occurs or the url is * {@code null} * @throws SQLTimeoutException when the driver has determined that the * timeout value specified by the {@code setLoginTimeout} method * has been exceeded and has at least tried to cancel the * current database connection attempt */ @CallerSensitive public static Connection getConnection(String url, String user, String password) throws SQLException { java.util.Properties info = new java.util.Properties(); if (user != null) { info.put(\"user\", user); } if (password != null) { info.put(\"password\", password); } return (getConnection(url, info, Reflection.getCallerClass())); } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-06 22:16:15 "},"67_桥接模式_注意事项.html":{"url":"67_桥接模式_注意事项.html","title":"注意事项","keywords":"","body":"桥接模式的注意事项和细节桥接模式的注意事项和细节 实现了抽象和实现部分的分离,从而极大的提供了系统的灵活性,让抽象部分和实现部分独立开来,这有助于系统进行分层设计,从而产生更好的结构化系统. 对于系统的高层部分,只需要知道抽象部分和实现部分的接口就可以了,其他的部分由具体业务来完成 桥接模式替代多层继承方案,可以减少子类的个数,降低系统的管理和维护成本. 桥接模式的引入增加了系统的理解和设计难度,由于聚合关联关系建立在抽象层,要求开发者针对抽象进行设计和编程. 桥接模式要求正确识别出系统中两个独立变化的维度,因此其使用范围有一定的局限性,即需要有这样的应用场景. 桥接模式的应用场景 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统,桥接模式尤为适用. 常见的应用场景: JDBC驱动程序 银行转账系统 转账分类: 网上转账,柜台转账,AMT转账 转行用户类型: 普通用户,银卡用户,金卡用户... 消息管理 消息类型: 即时消息,延时消息 消息分类: 手机短信,邮件消息,QQ消息... 桥接模式new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"71_装饰者模式_起步.html":{"url":"71_装饰者模式_起步.html","title":"起步","keywords":"","body":"星巴克咖啡1. 比较low的方案2.优化的方案方案2 问题分析装饰着模式定义装饰者原理图用装饰者模式设计的方案星巴克咖啡 星巴克咖啡订单项目(咖啡馆) 咖啡种类/单品咖啡: Espresso(意大利浓咖啡),ShortBlack,LongBlack(美式咖啡),Decaf(无因咖啡) 调料: milk,Soy(豆浆),Chocolate 要求在扩展 新的咖啡种类 时,具有良好的扩展性,改动方便,维护方便 使用OO来计算不同种类的咖啡的 费用: 客户可以点 单品咖啡 ,也可以 单品咖啡+调料组合 . 1. 比较low的方案 方案1-解决星巴克订咖啡订单问题分析 Drink 是一个抽象类,表示饮料 des就是对咖啡的描述,比如咖啡的名字 cost()方法就是计算费用,Drink类中做成一个抽象方法 Decaf就是单品咖啡,继承了Drink,并实现cost()方法 Espress&&Milk 就是单品咖啡+调料,这个组合很多 问题: 这样设计,会有很多类,当我们增加一个单品咖啡,或者一个新的调料,类的和数量就会倍增,就会出现类爆炸,peng~ 2.优化的方案 方案2- 解决星巴克咖啡订单(好点) 其那面分析到方案1因为 咖啡单品+调料 组合会造成类的倍增,因此可以做改进,将调料内置到Drink类,这样就不会造成类数量过多. 从而提高项目的维护性(如图) 说明: milk,soy,chocolate 可以设计为Boolean,表示是否要添加响应的调料 方案2 问题分析 方案2可以控制类的数量,不至于你造成很多类 在 增加或者删除调料种类时 ,代码的维护量很大 考虑到用户可以添加多份调料时,可以将这个hasMilk 返回一个对应的int类型 考虑使用装饰者模式(what???) 装饰着模式定义 装饰着模式: 动态的 将新功能附加到对象上.在对象功能扩展方面,它比继承更加有弹性,装饰者模式也体现了开闭原则(OCP) 这里提到的 动态的酱新功能附加到对象 和 OCP原则,在后面的应用实例上会以代码的形式体现,请同学们注意体会. 装饰者原理图 python 的装饰器 我艹,装饰者可以包含被装饰者 反向操作 用装饰者模式设计的方案 装饰者模式下订单: 2份巧克力+1份牛奶的LongBlack new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-05 18:10:20 "},"74_装饰者模式_代码实战.html":{"url":"74_装饰者模式_代码实战.html","title":"代码实战","keywords":"","body":"类图类图 package com.atguigu.decorator; public abstract class Drink { public String des; // 描述 private float price = 0.0f; public String getDes() { return des; } public void setDes(String des) { this.des = des; } public float getPrice() { return price; } public void setPrice(float price) { this.price = price; } // 计算费用 public abstract float cost(); } package com.atguigu.decorator; public class Coffee extends Drink{ @Override public float cost() { return getPrice(); } } package com.atguigu.decorator; public class Espresso extends Coffee{ // 构造器 public Espresso() { setDes(\"意大利咖啡\"); // 设置价格6块钱 setPrice(6.0f); } } package com.atguigu.decorator; public class LongBlack extends Coffee{ public LongBlack() { setDes(\"没事咖啡\"); setPrice(5.0f) } } package com.atguigu.decorator; public class ShortBlack extends Coffee{ public ShortBlack() { setDes(\"单品咖啡\"); setPrice(4.0f); } } package com.atguigu.decorator; public class Decorator extends Drink { private Drink obj; public Decorator(Drink obj) { // 组合 this.obj = obj; } @Override public float cost() { // 自己价格getprice return super.getPrice() + obj.cost(); } @Override public String getDes() { // 输出被装饰者信息 return des + \" \" + getPrice() + \"&&\" + obj.getDes(); // super不写也行 // return super.des + \" \" + super.getPrice() + \"&&\" + obj.getDes(); } } package com.atguigu.decorator; /** * 具体的Decorator,这里就是调味品 */ public class Chocolate extends Decorator{ public Chocolate(Drink obj) { super(obj); setDes(\"巧克力\"); // 调味品的价格,是3块钱 setPrice(3.0f); } } package com.atguigu.decorator; /** * */ public class Milk extends Decorator{ public Milk(Drink obj) { super(obj); setDes(\"牛奶\"); setPrice(2.0f); } } package com.atguigu.decorator; public class Soy extends Decorator{ public Soy(Drink obj) { super(obj); setDes(\"豆浆\"); setPrice(1.15f); } } 执行01 package com.atguigu.decorator; public class CoffeeBar { public static void main(String[] args) { // 用装饰者模式下订单,: 2份巧克力+1份牛奶的LongBlack // 1. 点一份 LongBlack Drink order = new LongBlack(); System.out.println(\"费用:\"+order.cost()); System.out.println(\"描述=\"+order.getDes()); /* 费用:5.0 描述=没事咖啡 Process finished with exit code 0 * */ } } 执行02 package com.atguigu.decorator; public class CoffeeBar { public static void main(String[] args) { // 用装饰者模式下订单,: 2份巧克力+1份牛奶的LongBlack // 1. 点一份 LongBlack Drink order = new LongBlack(); System.out.println(\"费用:\"+order.cost()); System.out.println(\"描述=\"+order.getDes()); // 2. 加一份牛奶 order = new Milk(order); // 参数就是返回值,相当于order被装饰了 // 相当于给我们第一份订单加入了一份牛奶 System.out.println(\"order加入一份牛奶 费用=\"+order.cost()); System.out.println(\"order加入一份牛奶 描述=\"+order.getDes()); /* 费用:5.0 描述=没事咖啡 order加入一份牛奶 费用=7.0 order加入一份牛奶 描述=牛奶 2.0&&没事咖啡 Process finished with exit code 0 * */ } } 执行03 package com.atguigu.decorator; public class CoffeeBar { public static void main(String[] args) { // 用装饰者模式下订单,: 2份巧克力+1份牛奶的LongBlack // 1. 点一份 LongBlack Drink order = new LongBlack(); System.out.println(\"费用:\"+order.cost()); System.out.println(\"描述=\"+order.getDes()); // 2. 加一份牛奶 order = new Milk(order); // 参数就是返回值,相当于order被装饰了 // 相当于给我们第一份订单加入了一份牛奶 System.out.println(\"order加入一份牛奶 费用=\"+order.cost()); System.out.println(\"order加入一份牛奶 描述=\"+order.getDes()); // 3. 加入一份巧克力 order = new Chocolate(order); System.out.println(\"order加入一份牛奶和巧克力 费用=\"+order.cost()); System.out.println(\"order加入一份牛奶和巧克力 描述=\"+order.getDes()); /* 费用:5.0 描述=没事咖啡 order加入一份牛奶 费用=7.0 order加入一份牛奶 描述=牛奶 2.0&&没事咖啡 order加入一份牛奶和巧克力 费用=10.0 order加入一份牛奶和巧克力 描述=巧克力 3.0&&牛奶 2.0&&没事咖啡 * */ } } 执行04 package com.atguigu.decorator; public class CoffeeBar { public static void main(String[] args) { // 用装饰者模式下订单,: 2份巧克力+1份牛奶的LongBlack // 1. 点一份 LongBlack Drink order = new LongBlack(); System.out.println(\"费用:\"+order.cost()); System.out.println(\"描述=\"+order.getDes()); // 2. 加一份牛奶 order = new Milk(order); // 参数就是返回值,相当于order被装饰了 // 相当于给我们第一份订单加入了一份牛奶 System.out.println(\"order加入一份牛奶 费用=\"+order.cost()); System.out.println(\"order加入一份牛奶 描述=\"+order.getDes()); // 3. 加入一份巧克力 order = new Chocolate(order); System.out.println(\"order加入一份牛奶和巧克力 费用=\"+order.cost()); System.out.println(\"order加入一份牛奶和巧克力 描述=\"+order.getDes()); // 4. 再加入一份巧克力 order = new Chocolate(order); System.out.println(\"order加入一份牛奶和2巧克力 费用=\"+order.cost()); System.out.println(\"order加入一份牛奶和2巧克力 描述=\"+order.getDes()); /* 费用:5.0 描述=没事咖啡 order加入一份牛奶 费用=7.0 order加入一份牛奶 描述=牛奶 2.0&&没事咖啡 order加入一份牛奶和巧克力 费用=10.0 order加入一份牛奶和巧克力 描述=巧克力 3.0&&牛奶 2.0&&没事咖啡 order加入一份牛奶和2巧克力 费用=13.0 order加入一份牛奶和2巧克力 描述=巧克力 3.0&&巧克力 3.0&&牛奶 2.0&&没事咖啡 * */ } } 课堂休息 同学有没有发现,这个模式的优势,我如果想要扩展,一个新的种类的咖啡,比如 DeCaf 咖啡,我只需要新建这个类之后,他就能和各个调料进行关联了 秒啊 看代码 我现在加上这个 package com.atguigu.decorator; public class DeCaf extends Coffee{ public DeCaf() { setDes(\"无因咖啡\"); setPrice(1.0f); } } 然后,看我操作 package com.atguigu.decorator; public class CoffeeBar { public static void main(String[] args) { System.out.println(\"-----------------------------\"); // 用装饰者模式下订单,: 2份巧克力+1份牛奶的LongBlack // 1. 点一份 LongBlack Drink order = new LongBlack(); System.out.println(\"order没事费用:\"+order.cost()); System.out.println(\"order没事描述=\"+order.getDes()); // 2. 加一份牛奶 order = new Milk(order); // 参数就是返回值,相当于order被装饰了 // 相当于给我们第一份订单加入了一份牛奶 System.out.println(\"order加入一份牛奶 费用=\"+order.cost()); System.out.println(\"order加入一份牛奶 描述=\"+order.getDes()); // 3. 加入一份巧克力 order = new Chocolate(order); System.out.println(\"order加入一份牛奶和巧克力 费用=\"+order.cost()); System.out.println(\"order加入一份牛奶和巧克力 描述=\"+order.getDes()); // 4. 再加入一份巧克力 order = new Chocolate(order); System.out.println(\"order加入一份牛奶和2巧克力 费用=\"+order.cost()); System.out.println(\"order加入一份牛奶和2巧克力 描述=\"+order.getDes()); System.out.println(\"-----------------------------\"); // 第二个订单,我喝无因咖啡 Drink order2 = new DeCaf(); System.out.println(\"order2无因费用:\"+order2.cost()); System.out.println(\"order2无因描述=\"+order2.getDes()); /* ----------------------------- order没事费用:5.0 order没事描述=没事咖啡 order加入一份牛奶 费用=7.0 order加入一份牛奶 描述=牛奶 2.0&&没事咖啡 order加入一份牛奶和巧克力 费用=10.0 order加入一份牛奶和巧克力 描述=巧克力 3.0&&牛奶 2.0&&没事咖啡 order加入一份牛奶和2巧克力 费用=13.0 order加入一份牛奶和2巧克力 描述=巧克力 3.0&&巧克力 3.0&&牛奶 2.0&&没事咖啡 ----------------------------- order2无因费用:1.0 order2无因描述=无因咖啡 * */ } } 我还可以直接用之前的调料ex牛奶 package com.atguigu.decorator; public class CoffeeBar { public static void main(String[] args) { System.out.println(\"-----------------------------\"); // 用装饰者模式下订单,: 2份巧克力+1份牛奶的LongBlack // 1. 点一份 LongBlack Drink order = new LongBlack(); System.out.println(\"order没事费用:\"+order.cost()); System.out.println(\"order没事描述=\"+order.getDes()); // 2. 加一份牛奶 order = new Milk(order); // 参数就是返回值,相当于order被装饰了 // 相当于给我们第一份订单加入了一份牛奶 System.out.println(\"order加入一份牛奶 费用=\"+order.cost()); System.out.println(\"order加入一份牛奶 描述=\"+order.getDes()); // 3. 加入一份巧克力 order = new Chocolate(order); System.out.println(\"order加入一份牛奶和巧克力 费用=\"+order.cost()); System.out.println(\"order加入一份牛奶和巧克力 描述=\"+order.getDes()); // 4. 再加入一份巧克力 order = new Chocolate(order); System.out.println(\"order加入一份牛奶和2巧克力 费用=\"+order.cost()); System.out.println(\"order加入一份牛奶和2巧克力 描述=\"+order.getDes()); System.out.println(\"-----------------------------\"); // 第二个订单,我喝无因咖啡 Drink order2 = new DeCaf(); System.out.println(\"order2无因费用:\"+order2.cost()); System.out.println(\"order2无因描述=\"+order2.getDes()); // 5. 加一份牛奶 order2 = new Milk(order2); // 参数就是返回值,相当于order2被装饰了 // 相当于给我们第一份订单加入了一份牛奶 System.out.println(\"order2加入一份牛奶 费用=\"+order2.cost()); System.out.println(\"order2加入一份牛奶 描述=\"+order2.getDes()); /* ----------------------------- order没事费用:5.0 order没事描述=没事咖啡 order加入一份牛奶 费用=7.0 order加入一份牛奶 描述=牛奶 2.0&&没事咖啡 order加入一份牛奶和巧克力 费用=10.0 order加入一份牛奶和巧克力 描述=巧克力 3.0&&牛奶 2.0&&没事咖啡 order加入一份牛奶和2巧克力 费用=13.0 order加入一份牛奶和2巧克力 描述=巧克力 3.0&&巧克力 3.0&&牛奶 2.0&&没事咖啡 ----------------------------- order2无因费用:1.0 order2无因描述=无因咖啡 order2加入一份牛奶 费用=3.0 order2加入一份牛奶 描述=牛奶 2.0&&无因咖啡 * */ } } 这你看,给我说NB 扩展思考 那我怎么减去一种咖啡呢 总结 这个不就是python中的装饰器么,搞得这么复杂 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-06 22:16:15 "},"75_装饰着模式_JDK源码.html":{"url":"75_装饰着模式_JDK源码.html","title":"JDK源码","keywords":"","body":"装死者模式在JDK应用的源码分析装死者模式在JDK应用的源码分析 直接上代码 package com.atguigu.jdk; import java.io.DataInputStream; import java.io.FileInputStream; public class Decorator { public static void main(String[] args) throws Exception{ DataInputStream dis = new DataInputStream( new FileInputStream(\"E:\\\\Projects\\\\IdeaProjects\\\\design_pattern\\\\out\\\\demo.txt\") ); /* demo.txt 文件内容: o * */ System.out.println(dis.read()); dis.close(); /* 111 * */ } } /** * A FileInputStream obtains input bytes * from a file in a file system. What files * are available depends on the host environment. * * FileInputStream is meant for reading streams of raw bytes * such as image data. For reading streams of characters, consider using * FileReader. * * @author Arthur van Hoff * @see java.io.File * @see java.io.FileDescriptor * @see java.io.FileOutputStream * @see java.nio.file.Files#newInputStream * @since JDK1.0 */ public class FileInputStream extends InputStream { /* File Descriptor - handle to the open file */ private final FileDescriptor fd; /** * The path of the referenced file * (null if the stream is created with a file descriptor) */ private final String path; private FileChannel channel = null; private final Object closeLock = new Object(); private volatile boolean closed = false; InputStream是一个抽象的 /** * This abstract class is the superclass of all classes representing * an input stream of bytes. * * Applications that need to define a subclass of InputStream * must always provide a method that returns the next byte of input. * * @author Arthur van Hoff * @see java.io.BufferedInputStream * @see java.io.ByteArrayInputStream * @see java.io.DataInputStream * @see java.io.FilterInputStream * @see java.io.InputStream#read() * @see java.io.OutputStream * @see java.io.PushbackInputStream * @since JDK1.0 */ public abstract class InputStream implements Closeable { // MAX_SKIP_BUFFER_SIZE is used to determine the maximum buffer size to // use when skipping. private static final int MAX_SKIP_BUFFER_SIZE = 2048; /** * Reads the next byte of data from the input stream. The value byte is * returned as an int in the range 0 to * 255. If no byte is available because the end of the stream * has been reached, the value -1 is returned. This method * blocks until input data is available, the end of the stream is detected, * or an exception is thrown. * * A subclass must provide an implementation of this method. * * @return the next byte of data, or -1 if the end of the * stream is reached. * @exception IOException if an I/O error occurs. */ public abstract int read() throws IOException; /** * A FilterInputStream contains * some other input stream, which it uses as * its basic source of data, possibly transforming * the data along the way or providing additional * functionality. The class FilterInputStream * itself simply overrides all methods of * InputStream with versions that * pass all requests to the contained input * stream. Subclasses of FilterInputStream * may further override some of these methods * and may also provide additional methods * and fields. * * @author Jonathan Payne * @since JDK1.0 */ public class FilterInputStream extends InputStream { /** * The input stream to be filtered. */ protected volatile InputStream in; /** * Creates a FilterInputStream * by assigning the argument in * to the field this.in so as * to remember it for later use. * * @param in the underlying input stream, or null if * this instance is to be created without an underlying stream. */ 敲黑板 package com.atguigu.jdk; import java.io.DataInputStream; import java.io.FileInputStream; public class Decorator { public static void main(String[] args) throws Exception{ // 说明 // 1. InputStream 是抽象类,类似我们前面的Drink // 2. FileInputStream 是 InputStream 子类,类似我们前面的DeCaf, LongBlack // 3. FilterInputStream 是 InputStream 子类: 类似我们其那面的 Decorator 修饰者 // 4. DataInputStream 是 FilterInputStream子类, 具体的修饰者,类似其那面的 Milk,Soy 等 // 5. FilterInputStream 类 有 protected volatile InputStream in; 即含被装饰者 // 6. 分析得出: 在jdk的IO体系中,就是使用装饰者模式 DataInputStream dis = new DataInputStream( new FileInputStream(\"E:\\\\Projects\\\\IdeaProjects\\\\design_pattern\\\\out\\\\demo.txt\") ); System.out.println(dis.read()); dis.close(); } } 一句话 装饰者模式: 动态的将新功能附加到对象上 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-06 22:16:15 "},"77_组合模式_院校展示.html":{"url":"77_组合模式_院校展示.html","title":"院校展示","keywords":"","body":"案例分析学校院系展示需求屌丝程序员方法传统方案解决学校院系展示存在的问题分析组合模式基本介绍类图组合模式解决学校院系展示案例分析 学校院系展示需求 后面的迭代器模式也用到了这个案例,这里要认真看,体会一下区别 编程实现展示一个学校院系结构: 需求是这样,要在一个页面中展示出学校的院系组成,一个学校有多个学院,一个学院有多个系. 如图: 我艹,这不是我的母校么 屌丝程序员方法 传统方案解决学校院系展示存在的问题分析 将学院看做是学校的子类,系是学院的子类,这样实际上是站在组织大小来进行区分层次的 实际上我们的要求是: 在一个页面中展示出学校的院系组成,一个学校有多个学院,一个学院有多个系,因此,这种方案,不能很好实现的管理的操作,比如,对学院,系 的 添加/删除/遍历 等等 解决方案: 把学校,院,系都 看做是 组织结构,他们之间没有继承关系,而是一个树形结构,可以更好的实现管理操作. => 组合模式 组合模式 基本介绍 组合模式,(Composite Pattern),又叫 部分整体模式 ,它创建了对象组的树形结构,将对象组合成树状结构以表示\"整体-部分\"的层次关系. 组合模式依据树形结构来组合对象,用来表示部分以及整体层次. 这种类型的设计模式属于结构型模式. 组合模式使得用户对单个对象和组合对象的访问具有一致性,即: 组合能让客户以一致的方式处理个别对象以及组合对象. 类图 对原理结构图的说明-即(组合模式的角色及职责) Component: 这是组合中对象声明接口,在适当情况下,实现所有类公有的接口默认行为,用于访问和管理Component 子部件,Component可以是抽象类或者接口 leaf: 在组合模式中表示的是叶子节点(最终的节点),也就是没有子节点 Composite: 非叶子节点,用于存储子部件,在Component接口中,实现子部件的相关操作,比如增加(add),删除.. 组合模式解决学校院系展示 应用实例要求 编写程序展示一个学校院系结构:需求是这样的,要在一个页面中展示出学校的院系组成,一个学校有多个学院,一个学院有多个系. 思路分析和图解(类图) 3. 代码实践 现在就是怎样一种关系呢 University中聚合的是College,College中聚合的是department package com.atguigu.composite; public abstract class OrganizationComponent { private String name; private String des; protected void add(OrganizationComponent organizationComponent) { // 默认实现 throw new UnsupportedOperationException(); } protected void remove(OrganizationComponent organizationComponent) { // 默认实现 throw new UnsupportedOperationException(); } // 构造器 public OrganizationComponent(String name, String des) { this.name = name; this.des = des; } // 方法打印,做成抽象的 protected abstract void print(); // 这个方法的子类都需要实现 public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDes() { return des; } public void setDes(String des) { this.des = des; } } package com.atguigu.composite; import java.util.ArrayList; import java.util.List; public class University extends OrganizationComponent{ List organizationComponents = new ArrayList<>(); // 构造器 public University(String name, String des, List organizationComponents) { super(name, des); this.organizationComponents = organizationComponents; } @Override protected void add(OrganizationComponent organizationComponent) { organizationComponents.add(organizationComponent); } @Override protected void remove(OrganizationComponent organizationComponent) { organizationComponents.remove(organizationComponent); } @Override public String getName() { return super.getName(); } @Override public String getDes() { return super.getDes(); } // print 方法,就是输出University 包含的学院 @Override protected void print() { System.out.println(\"------\"+getName()+\"-----\"); // 遍历organizationComponents for (OrganizationComponent organizationComponent : organizationComponents) { organizationComponent.print(); } } } package com.atguigu.composite; import java.util.ArrayList; import java.util.List; public class College extends OrganizationComponent { // 这个list中存放的是 department List organizationComponents = new ArrayList<>(); // 构造器 public College(String name, String des, List organizationComponents) { super(name, des); this.organizationComponents = organizationComponents; } @Override protected void add(OrganizationComponent organizationComponent) { // 在将来,实际业务中,这个College的add和University的add方法不一定完全相同 organizationComponents.add(organizationComponent); } @Override protected void remove(OrganizationComponent organizationComponent) { organizationComponents.remove(organizationComponent); } @Override public String getName() { return super.getName(); } @Override public String getDes() { return super.getDes(); } // print 方法,就是输出University 包含的学院 @Override protected void print() { System.out.println(\"------\"+getName()+\"-----\"); // 遍历organizationComponents for (OrganizationComponent organizationComponent : organizationComponents) { organizationComponent.print(); } } } package com.atguigu.composite; public class Department extends OrganizationComponent{ //构造 public Department(String name, String des) { super(name, des); } // 这个里面的add方法和 remove方法就可以不要了 @Override public String getName() { return super.getName(); } @Override public String getDes() { return super.getDes(); } @Override protected void print() { System.out.println(getName()); } } package com.atguigu.composite; public class Client { public static void main(String[] args) { // 从大到小创建对象 OrganizationComponent uni = new University(\"清华大学\", \"中国顶级的大学\"); // 创建学院 OrganizationComponent computerCollege = new College(\"计算机学院\", \"计算机IT技术NB\"); OrganizationComponent infoEngineerCollege = new College(\"信息学院\", \"信息与信号技术\"); computerCollege.add(new Department(\"软件工程\", \"软件工程NB\")); computerCollege.add(new Department(\"计算机科学与技术\", \"老牌专业\")); computerCollege.add(new Department(\"网络工程\", \"网络工程NB\")); infoEngineerCollege.add(new Department(\"信息工程\", \"信公秤不好学\")); infoEngineerCollege.add(new Department(\"通讯工程\", \"通公平不好学\")); // 将学院加入到学院中 uni.add(computerCollege); uni.add(infoEngineerCollege); uni.print(); // 这里你用谁打印,就输出谁的下面的信息 // 就灵活,比如你现在再有,一个级别,你可以把他聚合进来,嗯 /* ------清华大学----- ------计算机学院----- 软件工程 计算机科学与技术 网络工程 ------信息学院----- 信息工程 通讯工程 Process finished with exit code 0 * */ } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"78_组合模式_源码分析.html":{"url":"78_组合模式_源码分析.html","title":"JDK源码分析","keywords":"","body":"组合模式在JDK集合的源码分析组合模式在JDK集合的源码分析 看一下类图 package com.atguigu.jdk; import java.util.HashMap; import java.util.Map; public class Composite { public static void main(String[] args) { // 说明 // 1.Map 就是一个抽象的构建(类似我们的Component) // 2.HashMap是一个中间的构建(Composite),实现/继承了相关方法 // put,putall // 3.Node是 HashMap的静态累不累,类似Leaf叶子节点,这里就没有put,putall // static class Node implements Map.Entry Map hashMap = new HashMap(); hashMap.put(0,\"东游记\"); // 直接存放叶子节点 Map map = new HashMap(); map.put(1, \"西游记\"); map.put(2, \"红楼梦\"); hashMap.putAll(map); System.out.println(hashMap); } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-07 17:45:45 "},"79_组合模式_注意事项.html":{"url":"79_组合模式_注意事项.html","title":"注意事项","keywords":"","body":"组合模式的注意事项和细节组合模式的注意事项和细节 简化客户端操作.客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题 具有较强的扩展性.当我们要更改组合对象的时候,我们只需要调整内部的层次关系,客户端不用做出任何改动 方便创建出复杂的层次结构.客户端不用理会组合里面的组成细节,容易添加节点后者叶子从而创建出复杂的树形结构 需要遍历组织机构,或者处理的对象具有树形结构时,非常适合使用组合模式. 要求较高的抽象性,如果节点和叶子有很多差异性的话, 比如很多都不一样,不适合使用组合模式 一句话: 这个类之间的模式,有点儿像这个二叉树的数据结构 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-06 22:16:15 "},"81_外观模式_影院管理.html":{"url":"81_外观模式_影院管理.html","title":"影院管理","keywords":"","body":"先来一个案例外观模式基本介绍外观模式原理类图传统观念方式解决影院管理说明外观应用实例先来一个案例 影院管理 组建一个家庭影院: DVD播放,投影仪,自动屏幕,环绕立体声,爆米花机,要求完成使用家庭影院的功能,其过程为: 直接用遥控器:统筹各设备开关 开爆米花机 放下屏幕 开投影仪 开音响 开DVD,统筹各个设备开关 去拿爆米花 调暗灯光 播放 观影结束后,关闭各种设备 传统方式解决影院管理问题分析 在ClientTest 的main方法中,创建各个子系统的对象,并直接去调用子系统(对象)相关方法,会造成调用过程混乱,没有清晰的过程 不利于在ClientTest中,去维护对子系统的操作 解决思路: 定义一个高层接口,给子系统中的一组接口提供一个 一致的界面(比如在高层接口提供四个方法 ready,play,pause,end)用来访问子系统中的一群接口 也就是说 就是通过定义一个一致的接口(界面类),用以屏蔽内部子系统的细节,使得调用端只需跟这个接口发生调用,而无需关心这个子系统的内部细节 => 外观模式 一句话 说白了就是又封装了一层,然后嗯,客户端不用关心调用细节,提供了一个封装的面板类,面板界面来调用其他的接口 外观模式基本介绍 外观模式(Facade), 也叫做\"过程模式\": 外观模式为子系统中的一组接口提供一个一致的界面,此模式定义了一个高层接口,这个接口使得这以子系统更加容易使用 外观模式通过定义一个一致的接口,用以屏蔽内部子系统的细节,使得调用端只需跟这个接口发生调用,而无需关心这个子系统的内部细节 外观模式原理类图 原理类图的说明(外观模式的角色) 外观类(Facade): 为调用端提供统一的调用的接口,外观类知道哪些子系统负责处理请求,从而将调用端的请求代理给适当子系统对象 调用者(Clinet):外观接口的调用者 子系统的集合: 指模块或者子系统,处理Facade对象指派的任务,他是功能的提供者 传统观念方式解决影院管理说明 外观模式可用理解为转换一群接口,客户只要调用一个接口,而不用调用多个接口才能达到目的. 比如:在pc上安装软件的时候经常用一键安装选项(省去 选择安装目录,安装的组件等等),还有几十手机的重启功能(把关机和启动何为一个操作) 外观模式就是解决多个复杂接口带来的使用困难,起到简化用户操作的作用 示意图 外观应用实例 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-07 17:45:45 "},"82_外观模式_代码实战.html":{"url":"82_外观模式_代码实战.html","title":"代码实战","keywords":"","body":"代码实战关键的部分你来了代码实战 package com.atguigu.facade; public class DVDPlayer { // 使用单例模式,恶汉式 private static DVDPlayer instance = new DVDPlayer(); public static DVDPlayer getInstance() { return instance; } //开 public void on() { System.out.println(\"DVD ON\"); } // 关 public void off() { System.out.println(\"DVD off\"); } // 播放 public void play() { System.out.println(\"DVD play\"); } // 暂停 public void pause() { System.out.println(\"DVD pause\"); } } package com.atguigu.facade; // 爆米花 public class PopCorn { // 使用单例模式,恶汉式 private static PopCorn instance = new PopCorn(); public static PopCorn getInstance() { return instance; } //开 public void on() { System.out.println(\"PopCorn ON\"); } // 关 public void off() { System.out.println(\"PopCorn off\"); } // 播放 public void play() { System.out.println(\"PopCorn play\"); } // 暂停 public void pause() { System.out.println(\"PopCorn pause\"); } } package com.atguigu.facade; // 投影仪 public class Projector { // 使用单例模式,恶汉式 private static Projector instance = new Projector(); public static Projector getInstance() { return instance; } //开 public void on() { System.out.println(\"Projector ON\"); } // 关 public void off() { System.out.println(\"Projector off\"); } // 播放 public void play() { System.out.println(\"Projector play\"); } // 暂停 public void pause() { System.out.println(\"Projector pause\"); } // 暂停 public void focus() { System.out.println(\"聚焦 pause\"); } } package com.atguigu.facade; // 屏幕 public class Screen { private static Screen instance = new Screen(); public static Screen getInstance() { return instance; } public void up() { System.out.println(\"Screen up\"); } public void down() { System.out.println(\"Screen down\"); } } package com.atguigu.facade; public class Stereo { private static Stereo instance = new Stereo(); public static Stereo getInstance() { return instance; } // 开 public void on() { System.out.println(\"Stereo on\"); } // 关 public void off() { System.out.println(\"Stereo off\"); } // 音量调大 public void up() { System.out.println(\"Stereo up\"); } } package com.atguigu.facade; public class TheaterLigth { private static TheaterLigth instance = new TheaterLigth(); public static TheaterLigth getInstance() { return instance; } // 开 public void on() { System.out.println(\"TheaterLigth on\"); } // 关 public void dim() { System.out.println(\"TheaterLigth dim\"); } // 音量调大 public void bright() { System.out.println(\"TheaterLigth bright\"); } } 关键的部分你来了 package com.atguigu.facade; public class HomeTheaterFacade { // 定义各个子系统对象 private TheaterLigth theaterLigth; private PopCorn popCorn; private Stereo stereo; private Projector projector; private Screen screen; private DVDPlayer dvdPlayer; // 构造器 public HomeTheaterFacade() { super(); this.theaterLigth = TheaterLigth.getInstance(); this.popCorn = PopCorn.getInstance(); this.stereo = Stereo.getInstance(); this.projector = Projector.getInstance(); this.screen = Screen.getInstance(); this.dvdPlayer = DVDPlayer.getInstance(); } // 操作分成4 步 public void ready() { // 打开爆米花机 popCorn.on(); // 工作 popCorn.play(); // 屏幕下来 screen.down(); // 投影仪打开 projector.on(); // 立体声打开 stereo.on(); // DVD打开 dvdPlayer.on(); // 灯光调暗 theaterLigth.dim(); } // 播放 public void play() { dvdPlayer.play(); } // 暂停 public void pause() { dvdPlayer.pause(); } // 结束 public void end() { // 打开爆米花机 popCorn.off(); // 灯光调亮 theaterLigth.bright(); // 屏幕上去 screen.up(); // 投影仪打开 projector.off(); // 立体声打开 stereo.off(); // DVD打开 dvdPlayer.off(); } } package com.atguigu.facade; public class Client { public static void main(String[] args) { // 直接调用就很麻烦,嗯 // 不知道要调用谁 // 我封装好这个Home后,我就直接调用嗯 // 我整个影院就能够轻松控制 HomeTheaterFacade homeTheaterFacade = new HomeTheaterFacade(); homeTheaterFacade.ready(); homeTheaterFacade.play(); homeTheaterFacade.pause(); homeTheaterFacade.end(); /* PopCorn ON PopCorn play Screen down Projector ON Stereo on DVD ON TheaterLigth dim DVD play DVD pause PopCorn off TheaterLigth bright Screen up Projector off Stereo off DVD off Process finished with exit code 0 * */ } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-07 17:45:45 "},"83_外观模式_源码分析.html":{"url":"83_外观模式_源码分析.html","title":"源码分析","keywords":"","body":"外观模式在MyBatis框架应用的源码分析外观模式在MyBatis框架应用的源码分析 类图 你就直接调用Configuration就行了,他就是外观了类 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-07 17:45:45 "},"84_外观模式_注意事项.html":{"url":"84_外观模式_注意事项.html","title":"注意事项","keywords":"","body":"门面模式的结构外观模式的注意事项和细节 外观模式对完屏蔽了子系统的细节,一次外观模式降低了客户端对子系统使用的复杂性 外观模式对客户端与子系统的耦合关系,让子系统内部的模块更易维护和扩展 通过合理的使用外观模式,可以帮我们更好的划分访问的层次 当系统需要进行分层设计时,可以考虑使用Facade模式 在维护一个遗留的大型系统时,可能这个系统已经变得非常难以维护和扩展,此时可以考虑为新系统开发一个Facade类,来提供遗留系统的比较清晰简单的接口,让新系统与Facade类交互,提高复用性 不能过多的或者不合理的使用外观模式,使用外观模式,还是直接调用模块好.要以让系统有层次,利于维护为目的. 一句话 就是再封装一层 JAVA设计模式之门面模式（外观模式） 分类 编程技术 医院的例子 现代的软件系统都是比较复杂的，设计师处理复杂系统的一个常见方法便是将其\"分而治之\"，把一个系统划分为几个较小的子系统。如果把医院作为一个子系统，按照部门职能，这个系统可以划分为挂号、门诊、划价、化验、收费、取药等。看病的病人要与这些部门打交道，就如同一个子系统的客户端与一个子系统的各个类打交道一样，不是一件容易的事情。 首先病人必须先挂号，然后门诊。如果医生要求化验，病人必须首先划价，然后缴费，才可以到化验部门做化验。化验后再回到门诊室。 上图描述的是病人在医院里的体验，图中的方框代表医院。 解决这种不便的方法便是引进门面模式，医院可以设置一个接待员的位置，由接待员负责代为挂号、划价、缴费、取药等。这个接待员就是门面模式的体现，病人只接触接待员，由接待员与各个部门打交道。 门面模式的结构 门面模式没有一个一般化的类图描述，最好的描述方法实际上就是以一个例子说明。 由于门面模式的结构图过于抽象，因此把它稍稍具体点。假设子系统内有三个模块，分别是ModuleA、ModuleB和ModuleC，它们分别有一个示例方法，那么此时示例的整体结构图如下： 在这个对象图中，出现了两个角色： 门面(Facade)角色 ：客户端可以调用这个角色的方法。此角色知晓相关的（一个或者多个）子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。 子系统(SubSystem)角色 ：可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合（如上面的子系统就是由ModuleA、ModuleB、ModuleC三个类组合而成）。每个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。 源代码 子系统角色中的类： public class ModuleA { //示意方法 public void testA(){ System.out.println(\"调用ModuleA中的testA方法\"); } } public class ModuleB { //示意方法 public void testB(){ System.out.println(\"调用ModuleB中的testB方法\"); } } public class ModuleC { //示意方法 public void testC(){ System.out.println(\"调用ModuleC中的testC方法\"); } } 门面角色类： public class Facade { //示意方法，满足客户端需要的功能 public void test(){ ModuleA a = new ModuleA(); a.testA(); ModuleB b = new ModuleB(); b.testB(); ModuleC c = new ModuleC(); c.testC(); } } 客户端角色类： public class Client { public static void main(String[] args) { Facade facade = new Facade(); facade.test(); } } Facade类其实相当于A、B、C模块的外观界面，有了这个Facade类，那么客户端就不需要亲自调用子系统中的A、B、C模块了，也不需要知道系统内部的实现细节，甚至都不需要知道A、B、C模块的存在，客户端只需要跟Facade类交互就好了，从而更好地实现了客户端和子系统中A、B、C模块的解耦，让客户端更容易地使用系统。 门面模式的实现 使用门面模式还有一个附带的好处，就是能够有选择性地暴露方法。一个模块中定义的方法可以分成两部分，一部分是给子系统外部使用的，一部分是子系统内部模块之间相互调用时使用的。有了Facade类，那么用于子系统内部模块之间相互调用的方法就不用暴露给子系统外部了。 比如，定义如下A、B、C模块。 public class Module { /** * 提供给子系统外部使用的方法 */ public void a1(){}; /** * 子系统内部模块之间相互调用时使用的方法 */ private void a2(){}; private void a3(){}; } public class ModuleB { /** * 提供给子系统外部使用的方法 */ public void b1(){}; /** * 子系统内部模块之间相互调用时使用的方法 */ private void b2(){}; private void b3(){}; } public class ModuleC { /** * 提供给子系统外部使用的方法 */ public void c1(){}; /** * 子系统内部模块之间相互调用时使用的方法 */ private void c2(){}; private void c3(){}; } public class ModuleFacade { ModuleA a = new ModuleA(); ModuleB b = new ModuleB(); ModuleC c = new ModuleC(); /** * 下面这些是A、B、C模块对子系统外部提供的方法 */ public void a1(){ a.a1(); } public void b1(){ b.b1(); } public void c1(){ c.c1(); } } 这样定义一个ModuleFacade类可以有效地屏蔽内部的细节，免得客户端去调用Module类时，发现一些不需要它知道的方法。比如a2()和a3()方法就不需要让客户端知道，否则既暴露了内部的细节，又让客户端迷惑。对客户端来说，他可能还要去思考a2()、a3()方法用来干什么呢？其实a2()和a3()方法是内部模块之间交互的，原本就不是对子系统外部的，所以干脆就不要让客户端知道。 一个系统可以有几个门面类 在门面模式中，通常只需要一个门面类，并且此门面类只有一个实例，换言之它是一个单例类。当然这并不意味着在整个系统里只有一个门面类，而仅仅是说对每一个子系统只有一个门面类。或者说，如果一个系统有好几个子系统的话，每一个子系统都有一个门面类，整个系统可以有数个门面类。 为子系统增加新行为 初学者往往以为通过继承一个门面类便可在子系统中加入新的行为，这是错误的。门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为。比如医院中的接待员并不是医护人员，接待员并不能为病人提供医疗服务。 门面模式的优点 松散耦合: 门面模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。 简单易用: 门面模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟门面类交互就可以了。 更好的划分访问层次: 通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地隐藏了内部的细节。 原文地址：https://blog.csdn.net/jason0539/article/details/22775311new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-10 21:20:21 "},"86_享元模式_网站外包.html":{"url":"86_享元模式_网站外包.html","title":"网站外包","keywords":"","body":"网站外包展示网站项目需求传统方案解决网站展现项目传统方案解决网站展现项目问题分析享元模式定义网站外包 展示网站项目需求 小型的外包项目,给客户A做一个产品展示网站,客户A的朋友感觉效果不错,也希望做这样的产品展示网站,但是要求都有些不同: 有客户要求以新闻的形式发布 有客户人要求以博客的形式发布 有客户希望以微信公众号的形式发布 传统方案解决网站展现项目 直接复制粘贴一份,然后根据客户不同要求,进行定制修改 给每个网站租用一个空间 方案设计示意图 传统方案解决网站展现项目问题分析 需要的网站结构相似度很高,而且都不是高访问量网站,如果分成多个怩空间来处理的话,相当于一个相同网站实例对象很多,造成服务器的资源浪费 解决思路: 整合到一个网站中,共享其相关代码和数据,对于硬盘,内存,CPU,数据库空间等服务器资源都可以达成共享,减少服务器资源 对于代码来说,由于是一份实例,维护和扩展都更加容易 上面的解决思路就可以使用 享元模式 来解决 享元模式 定义 享元模式(Flyweight Pattern) 也叫蝇量模式:运用 共享技术有效地支持大量细粒度的对象 常用于系统底层开发,解决系统的性能问题.像 数据库连接池,里面都是创建好的连接对象,在这些对象中有我们需要的则直接拿来使用,避免重新创建,如果没有我们需要的,则创建一个 享元模式能够解决 重复对象的内存浪费的问题,当系统中有大量相似对象,需要缓冲池时.不需要总是创建新对象,可以从缓冲池里拿哦.这样可以降低系统内存,同时提高效率 享元模式 经典的应用场景 就是池技术了, String 常量池,数据库连接池,缓冲池等等都是享元模式的应用,享元模式是池技术的重要实现方式 这两个\"hello\" 他就是 嗯 用的一个 第二次new 的时候 这是在 堆空间中 创建了一个地址 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"87_享元模式_工作原理.html":{"url":"87_享元模式_工作原理.html","title":"工作原理","keywords":"","body":"原理类图 原理类图说明 FlyWeight 是抽象的享元角色,它是产品的抽象类,同时定义出对象的外部状态和内部状态(后面介绍) 的接口或实现 ConcreteFlyWeight 是具体的享元角色,是具体的产品类,实现抽象角色定义相关业务 UNSharedConcreteFlyWeight 是不可共享角色,一般不会出现在享元公厂. FlyWeightFactory 享元工厂类,用于构建一个池容器(集合,同时提供从池中获取的方法) 内部状态&外部状态 比如围棋,五子棋,跳棋,它们都有大量的棋子对象,围棋和五子棋只有黑白2色,跳棋颜色多一点儿,所以棋子颜色几十棋子内部状态;而各个棋子之间的差别就是位置的不同,当我们落子后,落子颜色是定的,但是位置变化的,所以棋子坐标就是棋子外部的状态 享元模式提出了两个要求:细粒度 和 共享对象. 这里就涉及到内部状态和外部状态了,即 将对象的信息分为2个部分:内部状态 和 外部状态 . 内部状态 指对象共享出来的信息,存储在享元对象内部且不会随环境的改变而改变 外部状态 指对象得以依赖的一个标记,是随环境改变而改变的,不可共享的状态. 举个例子: 围棋理论上有361个空位可以放棋子,每盘棋都有可能由两三百个棋子对象产生,因为内存空间有限,一台服务器很难支持更多的玩家玩围棋游戏,如果用享元模式来处理棋子,那么棋子对象就可以减少到只有2个实例,这样就很好的解决了对象的开销问题 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-07 17:45:45 "},"88_享元模式_代码实战.html":{"url":"88_享元模式_代码实战.html","title":"代码实战","keywords":"","body":"享元模式解决网站展现项目1. 应用实例类图优化版本类图看代码一句话享元模式解决网站展现项目 1. 应用实例 类图 package com.atguigu.flyweight; public abstract class WebSite { public abstract void use(); // 抽象方法 } package com.atguigu.flyweight; // 具体网站 public class ConcreteWebsite extends WebSite{ // 共享的部分,内部状态 private String type = \"\";//网站发布形式(类型) // 构造器 public ConcreteWebsite(String type) { this.type = type; } @Override public void use() { System.out.println(\"网站的发布形式为: \"+type+\"输出\"); } } package com.atguigu.flyweight; import java.util.HashMap; /** * 网站工厂类,根据需求返回一个网站 */ public class WebSiteFactory { // 集合,充当池的作用 private HashMap pool = new HashMap<>(); // 根据网站的类型,返回一个网站,如果没有就创建一个网站,并放入到池中,并返回 public WebSite getWebSiteCategory(String type) { if (!pool.containsKey(type)) { // 如果type在这个池子里面没有 // 就创建一个网站,并放入到池中 pool.put(type, new ConcreteWebsite(type)); } return (WebSite) pool.get(type); } // 获取网站分类总数(池子中有多少个网站类型) public int getWebSiteCount() { return pool.size(); } } 客户端 package com.atguigu.flyweight; public class Clinet { public static void main(String[] args) { System.out.println(); // 创建一个工厂类 WebSiteFactory factory = new WebSiteFactory(); // 现在客户要一个以新闻形式发布的网站 WebSite webSite1 = factory.getWebSiteCategory(\"新闻\"); webSite1.use(); /* 网站的发布形式为: 新闻输出 Process finished with exit code 0 * */ } } 现在需求又改了 package com.atguigu.flyweight; public class Clinet { public static void main(String[] args) { System.out.println(); // 创建一个工厂类 WebSiteFactory factory = new WebSiteFactory(); // 现在客户要一个以新闻形式发布的网站 WebSite webSite1 = factory.getWebSiteCategory(\"新闻\"); webSite1.use(); // 现在客户要一个以博客形式发布的网站 WebSite webSite2 = factory.getWebSiteCategory(\"博客\"); webSite2.use(); // 现在客户又要一个以博客形式发布的网站 WebSite webSite3 = factory.getWebSiteCategory(\"博客\"); webSite3.use(); /* 网站的发布形式为: 新闻输出 网站的发布形式为: 博客输出 网站的发布形式为: 博客输出 Process finished with exit code 0 * */ } } 前面的模式没有外部的状态(用户) 优化版本 类图 看代码 我加一个user类 package com.atguigu.flyweight; public class User { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } 这个要加上参数 package com.atguigu.flyweight; public abstract class WebSite { public abstract void use(User user); // 抽象方法 } 这个对应改一下 package com.atguigu.flyweight; // 具体网站 public class ConcreteWebsite extends WebSite{ // 共享的部分,内部状态 private String type = \"\";//网站发布形式(类型) // 构造器 public ConcreteWebsite(String type) { this.type = type; } @Override public void use(User user) { System.out.println(\"网站的发布形式为: \"+type+\"在使用中\"+\"使用者是\"+user.getName()); } } 客户端调用 package com.atguigu.flyweight; public class Clinet { public static void main(String[] args) { System.out.println(); // 创建一个工厂类 WebSiteFactory factory = new WebSiteFactory(); // 现在客户要一个以新闻形式发布的网站 WebSite webSite1 = factory.getWebSiteCategory(\"新闻\"); webSite1.use(new User(\"tom\")); // 现在客户要一个以博客形式发布的网站 WebSite webSite2 = factory.getWebSiteCategory(\"博客\"); webSite2.use(new User(\"victor\")); // 现在客户又要一个以博客形式发布的网站 WebSite webSite3 = factory.getWebSiteCategory(\"博客\"); webSite3.use(new User(\"smith\")); /* 网站的发布形式为: 新闻在使用中使用者是tom 网站的发布形式为: 博客在使用中使用者是victor 网站的发布形式为: 博客在使用中使用者是smith Process finished with exit code 0 * */ } } 一句话 他能够将外部状态和内部状态分开 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"89_享元模式_源码分析.html":{"url":"89_享元模式_源码分析.html","title":"源码分析","keywords":"","body":"享元模式在小结享元模式在 package com.atguigu.jdk; public class FlyWeight { public static void main(String[] args) { // TODO Integer x = Integer.valueOf(127); Integer y = new Integer(127); Integer z = Integer.valueOf(127); Integer w = new Integer(127); System.out.println(x.equals(y)); // true System.out.println(x == y); // false System.out.println(x == z); // true System.out.println(w == x); // false System.out.println(w == y); // false } } /** * Returns an {@code Integer} instance representing the specified * {@code int} value. If a new {@code Integer} instance is not * required, this method should generally be used in preference to * the constructor {@link #Integer(int)}, as this method is likely * to yield significantly better space and time performance by * caching frequently requested values. * * This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. * * @param i an {@code int} value. * @return an {@code Integer} instance representing {@code i}. * @since 1.5 */ public static Integer valueOf(int i) { if (i >= IntegerCache.low && i /** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the {@code -XX:AutoBoxCacheMax=} option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */ private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k = 127; } private IntegerCache() {} } 这里面有点儿像内个 python中的 对象 内存优化 的通过(引用)定义 实践出真知 package com.atguigu.jdk; public class FlyWeight { public static void main(String[] args) { // TODO // 如果Integer.valueOf(x) x 在-127---128之间,就是使用享元模式返回 // ,也就是说,要是有就返回,没有再创建 Integer x = Integer.valueOf(127); Integer y = new Integer(127); Integer z = Integer.valueOf(127); Integer w = new Integer(127); System.out.println(x.equals(y)); // true System.out.println(x == y); // false System.out.println(x == z); // true System.out.println(w == x); // false System.out.println(w == y); // false Integer x1 = Integer.valueOf(200); Integer x2 = Integer.valueOf(200); System.out.println(\"x1==x2:\"+(x1==x2)); /* true false true false false x1==x2:false Process finished with exit code 0 * */ } } 小结 在valueOf方法中,先判断值是否在IntegerCache 中, 如果不在,就创建新的Integer(new), 否则,就直接从缓存池中返回 valueOf方法 ,就使用到了 这个 享元模式. new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"90_享元模式_内容梳理.html":{"url":"90_享元模式_内容梳理.html","title":"内容梳理","keywords":"","body":"享元模式注意事项和细节 在享元模式这样理解, \"享\"就表示共享,\"元\"就表示对象 系统中有大量对象,这些对象消耗大量内存,并且对象的状态大部分可以外部化时,我么就可以考虑选用享元模式 用唯一标识码判断,如果在内存中有,则返回这个唯一标识码所标识的对象,用HashMap/HashTable存储 享元模式大大减少了对象的创建,降低了程序内存的占用,提高效率 享元模式提高了系统的复杂的.需要分离出内部状态和外部状态,而外部状态具有固化特性,不应该随着内部状态的改变而改变,这是我们使用享元模式需要注意的地方. 使用享元模式时,注意划分内部状态和外部状态,并且需要有一个工厂类加以控制. 享元模式经典的应用场景是需要缓冲池的场景,比如String 常量池,数据库连接池 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 17:27:51 "},"91_代理模式_基本介绍.html":{"url":"91_代理模式_基本介绍.html","title":"基本介绍","keywords":"","body":"代理模式(Proxy) 代理模式: 为一个对象提供一个替身,以控制对这个对象的访问. 即: 通过代理对象访问目标对象.这样做的好处是: 可以在目标对象实现的基础上,增强额外的功能操作,即:扩展目标对象的功能. 被代理的对象可以是远程对象,创建开销大的对象或者需要安全控制的对象 代理模式有不同的形式,主要有三种,静态代理,动态代理和Cglib代理(可以在内存动态的创建对象,而不需要实现接口,) 上图 Cglib代理也可以认为是动态代理 有些情况,这个TargetObject我不希望直接被调用到,比如有权限控制,或者安全,亦或者性能考虑 万能实际模式:加一层 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 19:51:40 "},"92_代理模式_静态代理.html":{"url":"92_代理模式_静态代理.html","title":"静态代理","keywords":"","body":"静态代理 静态代理在使用的时候,需要定义 接口或者父类,被代理对象(即目标对象)与代理对象一起实现相同的接口或者继承相同父类 应用实例 具体要求 定义一个接口:ITeacherDao 目标对象TeacherDao实现接口ITeactherDao 使用静态 代理方式,就需要在代理对象TeacherDaoProxy中也实现ITeacherDao 调用的时候通过调用代理对象的方法来调用目标对象. 特别提醒: 代理对象与目标对象要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法. 代理对象要聚合被代理对象 Client要创建TeacherDaoProxy代理对象 创建TeacherDao对象 将TeacherDao对象,交给TeacherDaoProxy对相,执行方法 代码实战 package com.atguigu.proxy; /** * 接口 */ public interface ITeacherDao { // 授课方法 void teach(); } package com.atguigu.proxy; public class TeacherDao implements ITeacherDao { @Override public void teach() { System.out.println(\"老师正在授课中...\"); } } package com.atguigu.proxy; /** * 代理对象,静态代理 */ public class TeeacherDaoProxy implements ITeacherDao { private ITeacherDao target; // 目标对象,通过接口来依赖(聚合)/关联 // 构造器 public TeeacherDaoProxy(ITeacherDao target) { this.target = target; } @Override public void teach() { System.out.println(\"代理对象开始代里\"); target.teach(); System.out.println(\"提交...\"); // 我怀疑这个是python中的装饰器 } } 客户端调用 package com.atguigu.proxy; public class Client { public static void main(String[] args) { System.out.println(\"代理模式!\"); // 创建目标对象(被代理对象) TeacherDao teacherDao = new TeacherDao(); // 创建代理对象,同时将被代理对象传递给代理对象 TeeacherDaoProxy teeacherDaoProxy = new TeeacherDaoProxy(teacherDao); // 通过代理对象,调用到被代理对象的方法 // 即: 执行的是代理对象的方法,代理对象再去调用目标对象的方法 teeacherDaoProxy.teach(); /* 代理模式! 代理对象开始代里 老师正在授课中... 提交... Process finished with exit code 0 * */ } } 静态代理优缺点 有点:在不修改目标对象的功能前提下,能通过代理对象对目标功能扩展 缺点: 因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类 一旦接口增加方法,目标对象与代理对象都要维护 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-07 18:52:08 "},"93_代理模式_动态代理.html":{"url":"93_代理模式_动态代理.html","title":"动态代理","keywords":"","body":"动态代理 动态代理模式的基本介绍 代理对象,不需要实现接口,但是目标对象要实现接口,否则不能用动态代理 代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象 动态代理也叫做: JDK代理,接口代理 JDK中生成代理的对象的API 代理类所在包: java.lang.reflect.Proxy JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完整的写法是 Static Object newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h) 案例实践 动态的返回对象 类图 getProxyInstance(): 根据传入的对象(TeacherDao) 利用返回机制,返回一个代理对象 然后通过代理对象,调用目标对象方法 代码演示 package com.atguigu.proxy.dynamic; public interface ITeacherDao { void teach(); // 授课方法 } package com.atguigu.proxy.dynamic; public class TeacherDao implements ITeacherDao{ @Override public void teach() { // System.out.println(\"老师正在授课中...\"); } } 重要部分来了,敲黑板 package com.atguigu.proxy.dynamic; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; /** * */ public class ProxyFactory { // 维护一个目标对象 private Object target; // 构造器,对target目标对象 进行初始化 public ProxyFactory(Object target) { this.target = target; } // 给目标对象生成一个代理对象 public Object getProxyInstance() { // /* * 说明 * @CallerSensitive public static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 参数说明 * * 1. ClassLoader loader: 指定当前目标对象爱你个使用的类加载器,获取加载器的方法固定 * 2. Class[] interfaces: 目标对象实现的接口类型,使用泛型方式确认类型 * 3. InvocationHandler h: 事件处理,执行目标对象的方法时,会触发事情处理器方法 * 会把当前执行的目标 对象方法作为参数传入 * */ return Proxy.newProxyInstance( // 第一个参数 target.getClass().getClassLoader(), // 第二个参数 target.getClass().getInterfaces(), // 第三个参数 new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\"JDK代理开始~~\"); // 反射机制调用目标对象的方法 Object returnVal = method.invoke(target, args); System.out.println(\"JDK代理提交~~\"); return returnVal; } } ); } } 客户端 package com.atguigu.proxy.dynamic; /** * 客户端 */ public class Client { public static void main(String[] args) { System.out.println(); // 创建目标对象 ITeacherDao target = new TeacherDao(); // 给目标对象,创建代理对象 // 用我们的代理工厂类 Object proxyInstance = new ProxyFactory(target).getProxyInstance(); // 可以转换成ITeacherDao ITeacherDao IProxyInstance = (ITeacherDao) proxyInstance; System.out.println(\"IProxyInstance=\"+IProxyInstance); System.out.println(\"IProxyInstance类型=\"+IProxyInstance.getClass()); //IProxyInstance类型=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象 // 通过代理对象调用目标对象的方法 IProxyInstance.teach(); /** * JDK代理开始~~ * JDK代理提交~~ * IProxyInstance=com.atguigu.proxy.dynamic.TeacherDao@12a3a380 * IProxyInstance类型=class com.sun.proxy.$Proxy0 * JDK代理开始~~ * 老师正在授课中... * JDK代理提交~~ * * Process finished with exit code 0 * */ } } 扩展功能 package com.atguigu.proxy.dynamic; public interface ITeacherDao { void teach(); // 授课方法 void sayHello(String hello);// 在家一个方法 } package com.atguigu.proxy.dynamic; public class TeacherDao implements ITeacherDao{ @Override public void teach() { // System.out.println(\"老师正在授课中...\"); } @Override public void sayHello(String name) { System.out.println(\"hello\"+name); } } package com.atguigu.proxy.dynamic; /** * 客户端 */ public class Client { public static void main(String[] args) { System.out.println(); // 创建目标对象 ITeacherDao target = new TeacherDao(); // 给目标对象,创建代理对象 // 用我们的代理工厂类 Object proxyInstance = new ProxyFactory(target).getProxyInstance(); // 可以转换成ITeacherDao ITeacherDao IProxyInstance = (ITeacherDao) proxyInstance; System.out.println(\"IProxyInstance=\"+IProxyInstance); System.out.println(\"IProxyInstance类型=\"+IProxyInstance.getClass()); //IProxyInstance类型=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象 // 通过代理对象调用目标对象的方法 IProxyInstance.teach(); IProxyInstance.sayHello(\"jack\"); /** * JDK代理开始~~ * JDK代理提交~~ * IProxyInstance=com.atguigu.proxy.dynamic.TeacherDao@12a3a380 * IProxyInstance类型=class com.sun.proxy.$Proxy0 * JDK代理开始~~ * 老师正在授课中... * JDK代理提交~~ * JDK代理开始~~ * hellojack * JDK代理提交~~ * * Process finished with exit code 0 * */ } } 静态代理是把将要被代理的类聚合到执行代理的类中嗯 动态代理是调用JDK系统的方法,来执行代理,能够带一些参数进去嗯 一句话 ,加了一层又new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-07 22:32:08 "},"94_代理模式_Cglib代理.html":{"url":"94_代理模式_Cglib代理.html","title":"Cglib代理","keywords":"","body":"Cglib代理Cglib基本介绍Cglib代理Cglibdialing模式实现步骤类图代码实战被代理敲黑板客户端Cglib代理 Cglib CGLib (Code Generation Library) 是一个强大的,高性能,高质量的Code生成类库。它可以在运行期扩展Java类与实现Java接口。 Hibernate用它来实现PO字节码的动态生成。CGLib 比 Java 的 java.lang.reflect.Proxy 类更强的在于它不仅可以接管接口类的方法，还可以接管普通类的方法。 CGLib 的底层是Java字节码操作框架 —— ASM。 查看 cglib 的 JavaDoc 文档。 基本介绍 静态代理和JDK代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实现任何接口,这个时候可使用目标对象子类来实现代理,这就是Cglib代理 Cglib代理也叫做子类代理,她是在内存中 构建一个子类对象从而实现对目标对象功能扩展,有些书也将Cglib代理归属到动态代理中. Cglib是一个强大的高性能代码生成包,他可以运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如SpringAOP,实现方法拦截 在AOP编程中如何选择代理模式: 目标对象需要实现接口,用JDK代理 目标对象不需要实现接口,用Cglib代理 Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类 > 被代理对象要是没有实现接口,这种情况下,我们也希望能够代理他 言而简直: jdk代理是用实现接口的方式,cglib是通过继承的方式 - (bili弹幕) Cglib代理 Cglibdialing模式实现步骤 需要引入cglib的jar文件 在内存中动态构建子类,注意代理的类不能为final,否则报错java.lang.illegalArgumentException: 目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法. 类图 类图解析 这个代理中 getInstance()给目标对象target创建一个代理对象 重写intecept方法,实现对被代理对象(目标对象)方法的调用 代码实战 asm-7.1.jar asm-commons-7.1.jar asm-tree-7.1.jar cglib-2.2.jar 通过mvn仓库,下载依赖jar包 被代理 package com.atguigu.proxy.cglib; public class TeacherDao { public void teach() { System.out.println(\"我是 cglib 代理, 不需要实现接口\"); System.out.println(\"老师授课中...\"); } } 敲黑板 package com.atguigu.proxy.cglib; import net.sf.cglib.proxy.Enhancer; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; public class ProxyFactory implements MethodInterceptor { /** * 维护一个目标对象 */ private Object target; /** * 构造器,传入一个倍代理的对象 * @param target */ public ProxyFactory(Object target) { this.target = target; } /** * 返回一个代理对象,是target对象的代理对象 * @return */ public Object getProxyInstance() { // `1. 创建工具类 Enhancer enhancer = new Enhancer(); // 2. 设置父类 enhancer.setSuperclass(target.getClass()); ///3. 设置回调函数 enhancer.setCallback(this); // 4. 创建子类对象及代理对象 return enhancer.create(); // 这个里面和我们的java的底层有一些关系 // 我们这里是代理模式,需要再说就讲到java底层了 // 这里就记住我们要返回一个目标对象的代理对象就可以了 } /** * 重写Intercept方法,这里面会调用目标对象的方法 * @param o * @param method * @param args * @param methodProxy * @return * @throws Throwable */ @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { // 这个方法里面将会实现对我们被代理(目标方法)的调用 System.out.println(\"Cglib代理模式~~开始\"); Object returnVal = method.invoke(target, args); System.out.println(\"Cglib代理~~提交~~\"); return returnVal; } /* * 很绕吧,也是就是你调用这个 getProxyInstance() 方法的时候,然后在你调用方法的时候 * 会触发intercept()这个方法,儿这个方法的里面就会去调用目标对象的某一个方法 * 完事儿,其实和其那面的模式像,只是他不用实现这个接口了,而被代理的类也不需要实现接口 * */ } 客户端 package com.atguigu.proxy.cglib; public class Client { public static void main(String[] args) { System.out.println(\"-------------\"); // 创建目标对象 TeacherDao target = new TeacherDao(); // 获取代理对象,并且将目标对象传递给代理对象 // 转换类型还要 TeacherDao proxyInstance = (TeacherDao) new ProxyFactory(target).getProxyInstance(); // 执行代理对象的方法,触发intercept方法,从而实现对目标对象的调用 proxyInstance.teach(); } } 加一个返回值 package com.atguigu.proxy.cglib; public class TeacherDao { public String teach() { System.out.println(\"我是 cglib 代理, 不需要实现接口\"); System.out.println(\"老师授课中...\"); return \"hello\"; } } package com.atguigu.proxy.cglib; public class Client { public static void main(String[] args) { System.out.println(\"-------------\"); // 创建目标对象 TeacherDao target = new TeacherDao(); // 获取代理对象,并且将目标对象传递给代理对象 // 转换类型还要 TeacherDao proxyInstance = (TeacherDao) new ProxyFactory(target).getProxyInstance(); // 执行代理对象的方法,触发intercept方法,从而实现对目标对象的调用 String res = proxyInstance.teach(); System.out.println(res); /** * hello * */ } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-07 22:32:09 "},"95_代理模式_几种变体.html":{"url":"95_代理模式_几种变体.html","title":"几种变体","keywords":"","body":"代理模式(proxy)的变体代理模式(proxy)的变体 几种常见的代理模式介绍-几种变体 防火墙代理 内网通过代理穿透防火墙,实现对公网的访问. 缓存代理 比如: 当请求图片文件等资源的时候,先到缓存代理取,如果取到资源则ok,如果取不到资源,再导公网或者数据库中取,然后缓存 远程代理 远程对象的本地代表,通过它可以吧远程对象当本地对象来调用.远程代理通过网络和真正的远程对象沟通信息. 同步代理: 主要使用在多线程编程中,完成多线程间的同步工作 > 这里面说的几种方式,只是代理的具体应用场景 核心还是其那面的那几种,静态代理,动态代理... new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-07 22:32:09 "},"96_模板模式_工作原理.html":{"url":"96_模板模式_工作原理.html","title":"工作原理","keywords":"","body":"豆浆制作问题 编写制作豆浆的程序.说明如下. 制作豆浆的流程 选材 => 添加配料 => 浸泡 => 放到豆浆机打碎 通过添加不同的配料,可以制作出不同口味的豆浆 选材,浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的 请使用 模板方法模式i完成 (说明: 以为模板方法模式,比较简单,很容易就想到这个方案),因此就直接使用,不再使用传统的方案来引出模板方法模式 音为模板方法比较简单,我们就不用传统方法来过渡了 模板方法模式基本介绍 模板方法模式(Template Method Pattern),又叫模板模式(Template Pattern),在一个抽象类公开定义了执行它的方法的模板.它的子类可以按需要重写方法实现,但是调用将以抽象类中定义的方式进行. 简单的说,模板方法模式 定义一个操作中的算法的骨架,而将一些步骤延迟到子类中,使得子类可以不改变一个算法结构,就可以重定义该算法的某些特定步骤 这种类型的设计模式属于行为型模式. 说白了,又是套一层 原理类图 说明 AbstractClass 抽象类,类中实现了模板方法,定义了算法的骨架,具体子类需要去实现,其他抽象方法 operation2,3,4 ConcreteClass 实现抽象方法operation2,3,4 ,以完成算法中特定子类的相关步骤 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 17:27:51 "},"97_模板模式_豆浆制作.html":{"url":"97_模板模式_豆浆制作.html","title":"豆浆制作","keywords":"","body":"应用实例要求 编写制作豆浆的程序,说明如下: 制作豆浆的流程 选材 => 添加配料 => 浸泡 => 放到豆浆机打碎 通过添加不同的配料,可以制作出不同口味的豆浆 选材,浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的(红豆,花生豆浆..) 类图 代码 package com.atguigu.template; public abstract class SoyaMilk { // 模板方法,make,模板方法可以做成final,不让子类去覆盖 final void make() { // 第一步 select(); addCondiments(); soak(); beat(); } // 选材料 void select() { System.out.println(\"第一步: 选择好的新鲜黄豆\"); } // 添加不同的配料,抽象方法,子类具体实现 abstract void addCondiments(); // 浸泡 void soak() { System.out.println(\"第三部,黄豆和配料开始浸泡,需要3小时\"); } // void beat() { System.out.println(\"第四部,黄豆和配料放到豆浆机去打碎!\"); } } package com.atguigu.template; public class RedBeanSoyaMilk extends SoyaMilk{ @Override void addCondiments() { System.out.println(\"加入上号的红豆\"); } } package com.atguigu.template; public class PeanutSoyaMilk extends SoyaMilk{ @Override void addCondiments() { System.out.println(\"加入上号的花生!\"); } } 客户端 package com.atguigu.template; public class Client { public static void main(String[] args) { System.out.println(\"---------\"); // 制作红豆豆浆 System.out.println(\"----制作红豆豆浆----\"); SoyaMilk redBeanSoyaMilk = new RedBeanSoyaMilk(); redBeanSoyaMilk.make(); System.out.println(\"----制作花生豆浆----\"); SoyaMilk peanutSoyMilk = new PeanutSoyaMilk(); peanutSoyMilk.make(); /** * --------- * ----制作红豆豆浆---- * 第一步: 选择好的新鲜黄豆 * 加入上号的红豆 * 第三部,黄豆和配料开始浸泡,需要3小时 * 第四部,黄豆和配料放到豆浆机去打碎! * ----制作花生豆浆---- * 第一步: 选择好的新鲜黄豆 * 加入上号的花生! * 第三部,黄豆和配料开始浸泡,需要3小时 * 第四部,黄豆和配料放到豆浆机去打碎! * * Process finished with exit code 0 */ } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 17:27:51 "},"98_模板模式_钩子方法.html":{"url":"98_模板模式_钩子方法.html","title":"钩子方法","keywords":"","body":"模板方法模式id钩子方法 在模板方法模式的父类中,我们可以定义一个方法,它默认不做任何事,子类可以视情况要不要覆盖它,该方法称为\"钩子\" 还是用上面做豆浆的例子来讲解,比如,我们还希望制作纯豆浆,不添加任何的配料,请使用钩子方法对其那面的模板方法进行改造 代码改进 package com.atguigu.template.improve; public abstract class SoyaMilk { // 模板方法,make,模板方法可以做成final,不让子类去覆盖 final void make() { // 第一步 select(); if (customerWantCondiments()) { addCondiments(); } soak(); beat(); } // 选材料 void select() { System.out.println(\"第一步: 选择好的新鲜黄豆\"); } // 添加不同的配料,抽象方法,子类具体实现 abstract void addCondiments(); // 浸泡 void soak() { System.out.println(\"第三部,黄豆和配料开始浸泡,需要3小时\"); } // void beat() { System.out.println(\"第四部,黄豆和配料放到豆浆机去打碎!\"); } // 钩子方法,决定是否添加配料 boolean customerWantCondiments() { // 默认返回 return true; } } package com.atguigu.template.improve; public class PeanutSoyaMilk extends SoyaMilk { @Override void addCondiments() { System.out.println(\"第二步 加入上号的花生!\"); } } package com.atguigu.template.improve; public class RedBeanSoyaMilk extends SoyaMilk { @Override void addCondiments() { System.out.println(\"第二步 加入上号的红豆\"); } } 这里加上 package com.atguigu.template.improve; public class PureSoyaMilk extends SoyaMilk{ @Override void addCondiments() { // 空实现 } @Override boolean customerWantCondiments() { // 重写这个地方 return false; } } 客户端 package com.atguigu.template.improve; public class Client { public static void main(String[] args) { System.out.println(\"---------\"); // 制作红豆豆浆 System.out.println(\"----制作红豆豆浆----\"); SoyaMilk redBeanSoyaMilk = new RedBeanSoyaMilk(); redBeanSoyaMilk.make(); System.out.println(\"----制作花生豆浆----\"); SoyaMilk peanutSoyMilk = new PeanutSoyaMilk(); peanutSoyMilk.make(); System.out.println(\"----制作纯豆浆----\"); SoyaMilk pureSoyMilk = new PureSoyaMilk(); pureSoyMilk.make(); /** * --------- * ----制作红豆豆浆---- * 第一步: 选择好的新鲜黄豆 * 第二步 加入上号的红豆 * 第三部,黄豆和配料开始浸泡,需要3小时 * 第四部,黄豆和配料放到豆浆机去打碎! * ----制作花生豆浆---- * 第一步: 选择好的新鲜黄豆 * 第二步 加入上号的花生! * 第三部,黄豆和配料开始浸泡,需要3小时 * 第四部,黄豆和配料放到豆浆机去打碎! * ----制作纯豆浆---- * 第一步: 选择好的新鲜黄豆 * 第三部,黄豆和配料开始浸泡,需要3小时 * 第四部,黄豆和配料放到豆浆机去打碎! * * Process finished with exit code 0 */ } } 钩子方法,他可以轻松的实现,哪一个方法在你的模板中要不要调用 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 17:27:51 "},"99_模板模式_IOC源码.html":{"url":"99_模板模式_IOC源码.html","title":"IOC源码","keywords":"","body":"IOC源码 钩子方法, onRefresh 如果父类做一个空实现,子类如果重写他,就按照子类的执行 如果要是子类不重写,那就啥也不干,嗯 让子类有一个灵活配置的机会 画一个类图 > > 设计模式只是一个考虑到思想的层面 有可能他实现的类下面还是有子类 而在这里我们可以不关心,嗯 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 17:27:51 "},"100_模板模式_细节说明.html":{"url":"100_模板模式_细节说明.html","title":"细节说明","keywords":"","body":"模板方法模式的注意事项和细节 基本思想是: 算法只存在于一个地方,也就是在父类中,容易修改. 需要修改算法时,只要修改父类的模板方法或者已经实现的某些步骤,子类就会继承这些修改 实现了最大化代码复用,父类的模板方法和已经实现的某些步骤会被子类继承而直接使用 即统一了算法,也提供了很大的灵活性.父类的模板方法确保了算法的结构保持不变,同时由子类提供部分步骤的实现. 该模式的不足之处: 每一个不同的实现都需要一个子类实现,导致类的个数增加,使得系统更加庞大 一般模板方法都加上final关键字,防止子类重写模板方法. 模板方法模式使用场景:当要完成在某个过程,改过程要执行一系列步骤,这一系列步骤基本相同,但是个别步骤在实现时可能不同,通常考虑用模板方法模式来处理哦 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"101_命令模式_工作原理.html":{"url":"101_命令模式_工作原理.html","title":"工作原理","keywords":"","body":"智能生活项目需求 看一个具体的需求 我们买了一套智能家电,有照明灯,风扇,冰箱,洗衣机,我们只要在手机上安装app就可以控制对这些家电的工作 这些智能家电来自不同的厂家,我们不想针对每一种家电都安装一个App,分别控制,我门希望只要一个app就可以控制全部智能家电. 要实现一个app控制所有智能家电的需要,则每个智能家电厂家都要提供一个统一的接口给app调用,这时就可以考虑使用命令模式. 命令模式可将\"动作的请求者\"从\"动作的执行者\"对象中解耦出来. 在我们的例子中,动作的请求者是手机app,动作的执行者是每个厂商的一个家电产品 这个???外观模式 命令模式基本介绍 命令模式(Command Pattern):在软件设计中,我们经常需要向某些对象发送请求,但是并不知道请求的接受者是谁,也不知道被请求的操作是哪一个,我们只需要在程序运行中指定具体的请求接受者即可,此时,可以使用命令模式来进行设计 命令模式使得请求发送者与请求接收者消除彼此之间的耦合,让对象之间的调用关系更加灵活,实现解耦 在命令模式中,会将一个请求封装为一个对象,以便使用不同参数来表示不同请求(即命名),同时命令模式也支持可撤销的操作. 通俗易懂的理解: 将军发布命令,士兵去执行.其中有几个角色:将军(命令发布者),士兵(命令的具体执行者),命令(连接将军和士兵). Invoker是调用者(将军),Receiver是被调用者(士兵),MyCommand是命令,实现了Command接口,持有接收对象 有些人发命令,但是它却不知道是谁在默默无闻的执行 唉! 内部类啊,太累了 原理类图 Invoker 和 Receiver 通过ConcreteCommand解耦了 Invoker 是调用者角色 Command 是命令角色,需要执行的所有命令都在这里,可以是接口或抽象类 Receiver : 是接收者角色,知道如何实施和执行一个请求相关的操作 ConcreteCommand: 将一个接受者与一个动作,调用接收者相应的操作,实现execute new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"101_命令模式_遥控控器.html":{"url":"101_命令模式_遥控控器.html","title":"遥控控器","keywords":"","body":"命令模式解决智能生活项目 命令模式应用实例 应用实例要求 编写程序,使用命令模式, 完成其那面的智能家电项目 我们有一个类,这个类相当于一个遥控器,每个按钮是分别对于不同的嗯的处理 类图 还要加一个空命令,简化我们的操作 现在只是有电灯,看我写好这个在进行扩展 代码实战 package com.atguigu.command; public interface Command { // 执行动作(操作_) public void execute(); // 撤销动作(操作 public void undo(); } package com.atguigu.command; public class LightReceiver { public void on() { System.out.println(\"电灯打开了\"); } public void off() { System.out.println(\"电灯关闭了\"); } } package com.atguigu.command; public class LightOnCommand implements Command { //聚合LightReceiver LightReceiver light; //构造器 public LightOnCommand(LightReceiver light) { super(); this.light = light; } @Override public void execute() { // 你认为它是打开 // 调用接受者的方法 light.on(); } @Override public void undo() { // 调用接受者的方法 light.off(); } } package com.atguigu.command; public class LightOffCommand implements Command { LightReceiver light; public LightOffCommand(LightReceiver light) { super(); this.light = light; } @Override public void execute() { // 调用接受者方法 light.off(); } @Override public void undo() { // 调用接受者方法 light.on(); } } package com.atguigu.command; /** * 没有任何命令,即;空执行,初始化 每个按钮, * 当调用空命令时,对象什么都不做 * 其实,这是一种设计模式,可以省掉对于空的判断 */ public class NoCommand { } package com.atguigu.command; public class RemoteController { // 开按钮的命令数组 Command[] onCommands; Command[] offCommands; // 执行撤销命令 Command undoCommand; // 构造器,初始化按钮 public RemoteController() { onCommands = new Command[5]; offCommands = new Command[5]; for (int i = 0; i 这不就是吧函数作为参数传递进去执行么,然后在归拢归拢 看看怎么执行 万能设计模式-加一层 我把一堆要调用的函数,我存放在数组里面,然后你调用哪个我拿出来哪个 就是这么回事儿 选择性的调用某个数组中之前存的方法,然后方便调用撤销 可也实现 用 go 没有这么麻烦就能实现 客户端 package com.atguigu.command; public class Client { public static void main(String[] args) { // 使用命令设计模式 // 完成通过遥控器对电灯的操作 // 创建电灯的对象,(接受者 LightReceiver lightReceiver = new LightReceiver(); // 创建电灯的相关的开关命令 LightOnCommand lightOnCommand = new LightOnCommand(lightReceiver); // 创建电灯的开关命令 LightOffCommand lightOffCommand = new LightOffCommand(lightReceiver); // 需要一个遥控器 RemoteController remoteController = new RemoteController(); //给我们的遥控器设置相关的命令, 比如no= 0 的是电灯的开和关的操作 remoteController.setCommand(0, lightOnCommand, lightOffCommand); System.out.println(\"-----按下灯的开的按钮------\"); remoteController.onButtonWasPushed(0); System.out.println(\"-----按下灯的关的按钮------\"); remoteController.offButtonWasPushed(0); System.out.println(\"-----撤销-----------------\"); remoteController.undoButtonWasPushed(); /** * -----按下灯的开的按钮------ * 电灯打开了 * -----按下灯的关的按钮------ * 电灯关闭了 * -----撤销----------------- * 电灯打开了 * * Process finished with exit code 0 */ } } 扩展 要符合开闭原则,所有这个RemoteController 应不用变化 加一个电视的 package com.atguigu.command; public class TVReceiver { public void on() { System.out.println(\"电视打开了\"); } public void off() { System.out.println(\"电视关闭了\"); } } package com.atguigu.command; public class TVOnCommand implements Command { //聚合TVReceiver TVReceiver tv; //构造器 public TVOnCommand(TVReceiver tv) { super(); this.tv = tv; } @Override public void execute() { // 你认为它是打开 // 调用接受者的方法 tv.on(); } @Override public void undo() { // 调用接受者的方法 tv.off(); } } package com.atguigu.command; public class TVOffCommand implements Command { TVReceiver tv; public TVOffCommand(TVReceiver tv) { super(); this.tv = tv; } @Override public void execute() { // 调用接受者方法 tv.off(); } @Override public void undo() { // 调用接受者方法 tv.on(); } } 客户端调用 package com.atguigu.command; public class Client { public static void main(String[] args) { // 使用命令设计模式 // 完成通过遥控器对电灯的操作 // 需要一个遥控器 RemoteController remoteController = new RemoteController(); // 创建电灯的对象,(接受者 LightReceiver lightReceiver = new LightReceiver(); // 创建电灯的相关的开关命令 LightOnCommand lightOnCommand = new LightOnCommand(lightReceiver); // 创建电灯的开关命令 LightOffCommand lightOffCommand = new LightOffCommand(lightReceiver); //给我们的遥控器设置相关的命令, 比如no= 0 的是电灯的开和关的操作 remoteController.setCommand(0, lightOnCommand, lightOffCommand); System.out.println(\"-----按下灯的开的按钮------\"); remoteController.onButtonWasPushed(0); System.out.println(\"-----按下灯的关的按钮------\"); remoteController.offButtonWasPushed(0); System.out.println(\"-----撤销-----------------\"); remoteController.undoButtonWasPushed(); // 创建电视的对象,(接受者 TVReceiver tvReceiver = new TVReceiver(); // 创建电视的相关的开关命令 TVOnCommand tvOnCommand = new TVOnCommand(tvReceiver); // 创建电视的开关命令 TVOffCommand tvOffCommand = new TVOffCommand(tvReceiver); //给我们的遥控器设置相关的命令, 比如no= 1 的是电视的开和关的操作 remoteController.setCommand(1, tvOnCommand, tvOffCommand); System.out.println(\"-----按下视的开的按钮------\"); remoteController.onButtonWasPushed(1); System.out.println(\"-----按下视的关的按钮------\"); remoteController.offButtonWasPushed(1); System.out.println(\"-----撤销-----------------\"); remoteController.undoButtonWasPushed(); /** *-----按下灯的开的按钮------ * 电灯打开了 * -----按下灯的关的按钮------ * 电灯关闭了 * -----撤销----------------- * 电灯打开了 * -----按下视的开的按钮------ * 电视打开了 * -----按下视的关的按钮------ * 电视关闭了 * -----撤销----------------- * 电视打开了 * * Process finished with exit code 0 */ } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 17:27:51 "},"103_命令模式_JDBC源码.html":{"url":"103_命令模式_JDBC源码.html","title":"JDBC源码","keywords":"","body":"命令模式在Spring框架Jdbc Template应用的源码分析 模式角色分析 StatementCallback 接口,类似命令接口 class QueryStatementCallback implements StatementCallback,SQLProvider,匿名累不累,实现了命令接口,同时也充当命令接受者 命令调用者是JdbcTemplate,其中execute(StatementCallback action)方法中,调用action.doInStatement方法. 不同的实现(StatementCallback接口的对象,对应不同的doInStatement实现逻辑) 另外实现 StatementCallback命令接口的子类还有QueryStatementCallback, > > 我们将的模式是一种标准的写法,而在这种实际的源码中, 他可能有用到这种模式,但是它不标准,因为开发他的人, 他在无意间写出的这种模式,他自己不知道啊 这个只是我们后人归纳好的一种一厢情愿 这个设计模式它是一种思想,他只要是满足这种思想就算! new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 17:27:51 "},"105_命令模式_内容梳理.html":{"url":"105_命令模式_内容梳理.html","title":"内容梳理","keywords":"","body":"命名模式的注意事项和细节 命令模式的注意事项和细节 将发起请求的对象与执行请求的对象解耦.发起请求的对象是调用者,调用者只要调用命令对象的execute()方法就可以让接受者工作,而不必知道具体的接收者对象是谁,他也不认识他对象,也不知道是如何实现的,命令对象会负责让接受者执行请求的动作,也就是说:\"请求发起者\"和\"请求执行者\"之间的解耦是通过命令对象实现的,命令对象起到了纽带桥梁的作用. 容易设计一个命令队列.只要把命令对象放到队列,就可以多线程的执行命令 容易实现对请求的撤销和重做 命令模式的不足: 可能导致某些系统有过多的具体命令类,增加了系统的复杂度,这点在使用的时候要注意一下 空命令他也是一种设计模式,他为我们省去了判断空的操作.在上面的实例中,如果没有用空命令,我们没按下一个按键都要去判断空,这给我们编码带来了一定的麻烦. 命令模式经典的应用场景:界面的一个按钮都是一条命令,模拟CMD(DOS命令)订单的撤销/恢复,出发-反馈机制 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 17:27:51 "},"106_访问者模式_歌手评分.html":{"url":"106_访问者模式_歌手评分.html","title":"歌手评分","keywords":"","body":"测评系统需求 完成测评系统需求 将观众分为男人和女人,对歌手进行评测,当看完某个歌手表演后,得到他们对改歌手不同的评价(评价 有不同的种类,比如 成功 失败 等) 传统方案 传统方式的问题分析 如果系统比较小,还是ok,但是考虑系统增加越来越多的新的功能时,对代码的改动较大,违反了OCP原则,不利于维护 扩展性不好,比如增加了新的人员类型,或者管理方法,都不好做 引出我们会使用的新的一种设计模式 - 访问者模式 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 18:43:38 "},"107_访问者模式_原理类图.html":{"url":"107_访问者模式_原理类图.html","title":"原理类图","keywords":"","body":"访问者模式基本介绍 访问者模式(visitor Pattern),封装一些作用域某种数据结构的各元素的操作,它可以在不改变数据结构的前提下定义作用于这些元素的新的操作 主要讲数据结构与数据操作分离,解决 数据结构和操作耦合性问题 访问者模式的基本工作原理是: 在被访问的类里面加一个对外提供接待访问者的接口 访问者模式主要应用场景是: 需要对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联),同时需要避免让这些操作污染这些对象的类,可以选用访问者模式解决 类图 对原理类图的说明 即(访问者模式的角色及职责) Visitor是抽象访问者,为该对象结构中的ConcreteElement的每一个类声明一个visitor操作 ConcreteVisitor: 是一个具体的访问值 实现每个有Visitor声明的操作,是每个操作实现的部分 ObjectStructure能枚举他的元素,可提供一个高层的接口,用来允许访问者访问他的元素. Element定义了一个accept方法,可以接收一个访问者对象 ConcreteElement为具体的元素,实现了accept方法 这个...太抽象了 我完全不知道你在说什么 学设计模式有这个过程,就是有可能吧这个原理类图和文字都说了,你还是不知道老师在说啥 这些地方都太理论化了 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 18:51:56 "},"108_访问者模式_代码实践.html":{"url":"108_访问者模式_代码实践.html","title":"代码实践","keywords":"","body":"访问者模式类图代码Person类(基础)成功类(必要)失败类男人类女人类动作类(核心)数据结构类(关键)客户端一句话访问者模式 类图 画 的不对, 重新画一下 代码 Person类(基础) package com.atguigu.visitor; /** * @author victor * @site https://victorfengming.gitee.io/ * @project design_pattern * @package com.atguigu.visitor * @created 2021-02-08 19:01 */ public abstract class Person { // 提供一个方法,让访问者可以访问 public abstract void accept(Action action); } 成功类(必要) package com.atguigu.visitor; /** * @author victor * @site https://victorfengming.gitee.io/ * @project design_pattern * @package com.atguigu.visitor * @created 2021-02-08 19:02 */ public class Success extends Action { @Override public void getManResult(Man man) { System.out.println(\"男的给的评价是该歌手 很成功 !\"); } @Override public void getWomanResult(Woman woman) { System.out.println(\"女人给他评价很成功!\"); } } 失败类 package com.atguigu.visitor; /** * @author victor * @site https://victorfengming.gitee.io/ * @project design_pattern * @package com.atguigu.visitor * @created 2021-02-08 19:03 */ public class Fail extends Action{ @Override public void getManResult(Man man) { System.out.println(\"男人给的评价是失败\"); } @Override public void getWomanResult(Woman woman) { System.out.println(\"女的给他的评价也是失败的 \"); } } 男人类 package com.atguigu.visitor; /** * @author victor * @site https://victorfengming.gitee.io/ * @project design_pattern * @package com.atguigu.visitor * @created 2021-02-08 19:01 */ public class Man extends Person { @Override public void accept(Action action) { action.getManResult(this); } } 女人类 package com.atguigu.visitor; /** * @author victor * @site https://victorfengming.gitee.io/ * @project design_pattern * @package com.atguigu.visitor * @created 2021-02-08 19:01 * 说明 * 1. 这里我们使用到了双分派, * 即首先在客户端程序中,将具体的状态作为参数传递到了Woman中 * 2. 然后Woman 类 调用了作为参数的\"具体方法\"中的方法 getWomanResult, * 同时将自己(this)作为参数传入,完成第二次分派 * * 这种分派的方式能够做到一个解耦,处理能够方便一点儿 */ public class Woman extends Person{ @Override public void accept(Action action) { action.getWomanResult(this); } } 说明 这里我们使用到了双分派, 即首先在客户端程序中,将具体的状态作为参数传递到了Woman中 然后Woman 类 调用了作为参数的\"具体方法\"中的方法 getWomanResult, 同时将自己(this)作为参数传入,完成第二次分派 动作类(核心) package com.atguigu.visitor; /** * @author victor * @site https://victorfengming.gitee.io/ * @project design_pattern * @package com.atguigu.visitor * @created 2021-02-08 18:58 */ public abstract class Action { // 得到男性的一个测评结果 public abstract void getManResult(Man man); // Action依赖man ,man也要用action // 得到女的评测 public abstract void getWomanResult(Woman woman); } 数据结构类(关键) package com.atguigu.visitor; import java.util.LinkedList; import java.util.List; /** * @author victor * @site https://victorfengming.gitee.io/ * @project design_pattern * @package com.atguigu.visitor * @created 2021-02-08 19:16 */ /** * 数据结构,管理很多人,有man,有woman */ public class ObjectStructure { // 维护了一个集合 private List persons = new LinkedList<>(); // 增加到list public void attach(Person p) { persons.add(p); } // 移除 public void detach(Person p) { persons.remove(p); } // 显示测评的情况 public void display(Action action) { for (Person person : persons) { person.accept(action); } } } 客户端 简易 package com.atguigu.visitor; public class Client { public static void main(String[] args) { System.out.println(\"-----------\"); // 创建ObjectStructure ObjectStructure objectStructure = new ObjectStructure(); // 1男1女 objectStructure.attach(new Man()); objectStructure.attach(new Woman()); // 成功 Success success = new Success(); objectStructure.display(success); /** * ----------- * 男的给的评价是该歌手 很成功 ! * 女人给他评价很成功! * * Process finished with exit code 0 */ } } 扩展 package com.atguigu.visitor; public class Client { public static void main(String[] args) { System.out.println(\"-----------\"); // 创建ObjectStructure ObjectStructure objectStructure = new ObjectStructure(); // 1男1女 objectStructure.attach(new Man()); objectStructure.attach(new Woman()); // 成功 Success success = new Success(); objectStructure.display(success); System.out.println(\"--------->\"); Fail fail = new Fail(); objectStructure.display(fail); /** * ----------- * 男的给的评价是该歌手 很成功 ! * 女人给他评价很成功! * ---------> * 男人给的评价是失败 * 女的给他的评价也是失败的 * * Process finished with exit code 0 */ } } 一句话 多次一举 理解不了liao new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 19:41:56 "},"109_访问者模式_双分派.html":{"url":"109_访问者模式_双分派.html","title":"双分派","keywords":"","body":"访问者模式应用实例 应用案例的小结 上面提到了双分派,所谓双分派是值不管类怎么变化,我们都能够找到期望的方法运行双分派意味着得到执行的操作取决于请求的种类和两个接受者类型 以上数实例为例,假设我么要添加一个Wait的状态类,考察Man类和Woman类的反应,由于使用了双分派,只需要增加一个Action子类即可在客户端调用即可,不需要改动任何其他类的代码 看类图怎么加的 我这个代码怎么动 在代码中加这么一个类(扩展) package com.atguigu.visitor; /** * @author victor * @site https://victorfengming.gitee.io/ * @project design_pattern * @package com.atguigu.visitor * @created 2021-02-08 19:35 */ public class Wait extends Action { @Override public void getManResult(Man man) { System.out.println(\"男人给的评价是待定about这个歌手\"); } @Override public void getWomanResult(Woman woman) { System.out.println(\"女人给的歌手评价是待定\"); } } 在Client端 package com.atguigu.visitor; /** * @author victor * @site https://victorfengming.github.io/ * @project design_pattern * @package com.atguigu.visitor * @created 2021-02-08 18:52 * @function \"\" */ public class Client { public static void main(String[] args) { System.out.println(\"-----给成功------\"); // 创建ObjectStructure ObjectStructure objectStructure = new ObjectStructure(); // 1男1女 objectStructure.attach(new Man()); objectStructure.attach(new Woman()); // 成功 Success success = new Success(); objectStructure.display(success); System.out.println(\"####给失败####>\"); Fail fail = new Fail(); objectStructure.display(fail); System.out.println(\">>>>>给待定>>>>>\"); Wait wait = new Wait(); objectStructure.display(wait); /** * -----给成功------ * 男的给的评价是该歌手 很成功 ! * 女人给他评价很成功! * ####给失败####> * 男人给的评价是失败 * 女的给他的评价也是失败的 * >>>>>给待定>>>>> * 男人给的评价是待定about这个歌手 * 女人给的歌手评价是待定 * * Process finished with exit code 0 */ } } 当然你也可以扩展出这个 man和woman 的名字 本案例中由于懒就不加了 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"110_访问者模式_使用细节.html":{"url":"110_访问者模式_使用细节.html","title":"使用细节","keywords":"","body":"访问者模式的注意事项和细节优点缺点访问者模式的注意事项和细节 优点 访问者模式符合的单一职责原则,让程序具有优秀的扩展性,灵活性非常高 访问者模式可以对功能进行统一,可以做报表,UI,拦截器,与过滤器,适用于数据结构相对稳定的系统 缺点 具体元素对访问者公布细节,也就是说访问者关注了其他类的内部细节,这是迪米特法则所不建议的,这样造成了具体元素变更比较困难 违背了依赖倒转原则.访问者依赖的是具体元素,而不是抽象元素 因此,如果一个系统有比较稳定的数据结构,又有经常变化的功能需求,那么访问者模式就是比较适合的. new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 19:50:33 "},"111_迭代器模式_统一遍历.html":{"url":"111_迭代器模式_统一遍历.html","title":"统一遍历","keywords":"","body":"统一遍历问题传统的设计方案(类图)传统模式id问题分析迭代器 VS 组合模式统一遍历问题 编写程序展示一个学校院系结构:需求是这样的,要在一个页面中展示出学校的院系组成,一个学校有多个学院,一个学院有多个系 前面的组合模式也用到了这个案例,这里要认真看,体会一下区别 传统的设计方案(类图) 传统模式id问题分析 我现在比如我的计算机学院的系的信息是存在一个数组中的, 但是我这个信息工程学院的信息是存储在集合中了 然后就涉及到一个遍历的问题,我们怎么能够把他们统一的遍历出来 这个时候就需要我们这个迭代器模式了 将学院看做是学校子类,系是学院的子类,这样实际上是站在组织大小来进行分层次的 实际上我们的要求是: 在一个页面中展示出学校的院系组成,一个学校有多个学院,一个学院有多个系,因此这种方案,不能很好的实现遍历的操作. 解决方案: => 迭代器模式 迭代器 VS 组合模式 迭代器注重的是遍历,组合模式注重各个组成部分 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"112_迭代器模式_原理类图.html":{"url":"112_迭代器模式_原理类图.html","title":"原理类图","keywords":"","body":"迭代器模式概念类图一个数组类型扩展另一类型类图解析在严谨一点新的类图迭代器模式概念 迭代器模式(Iterator pattern)是常用的设计模式,属于行为型模式 如果我们的集合元素是用不同的方式实现的,有数组,还有Java的集合类或者还有其他方式,当客户端要遍历这些集合元素的时候,就要使用多种遍历方式,而且还会暴漏元素的内部结构,可以考虑使用迭代器模式解决. 迭代器模式,提供一种遍历集合元素的统一接口,用一致的方法遍历集合元素,不需要知道集合对象的底层表示,即: 不暴露其内部的结构. 类图 一个数组类型 扩展另一类型 类图解析 对原理图的说明 Iterator: 迭代器接口,是系统提供,含义hasNext,next,remove ConcreteIterator: 具体的迭代器类,管理迭代 Aggregate: 一个统一的聚合接口,将客户 ConcreteAggregate: 具体的聚合持有对象集合,并提供一个方法,返回一个迭代器,该迭代器可以正确遍历集合 Client:客户端,他通过Iterator和Aggregate依赖子类 在严谨一点 应该有一个Element 新的类图 懵逼中... new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-09 18:28:42 "},"113_迭代器模式_代码实践.html":{"url":"113_迭代器模式_代码实践.html","title":"代码实践","keywords":"","body":"迭代器模式实战类图部分关联代码department计算机学院(生成)信息工程学院(生成)College计算机学院信息学院输出类客户端迭代器模式实战 类图 部分 关联 代码 department package com.atguigu.iterator; /** * @author victor * @site https://victorfengming.gitee.io/ * @project design_pattern * @package com.atguigu.iterator * @created 2021-02-08 20:51 */ // 系 public class Department { private String name; private String desc; public Department(String name, String desc) { this.name = name; this.desc = desc; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } } 计算机学院(生成) package com.atguigu.iterator; import java.util.Iterator; /** * @author victor * @site https://victorfengming.gitee.io/ * @project design_pattern * @package com.atguigu.iterator * @created 2021-02-08 20:53 */ public class ComputerCollegeIterator implements Iterator { // 这里我们需要知道 Department 是 以 怎样的方式 存放的 // 我们假定这个computerCollege 计算机学院 他的存放方式是以数组的形式存放的 Department[] departments; int position = 0; // 遍历的位置 // 吧department内容传进来, // 我要知道你是怎么存放的,你不告诉我我无法迭代 public ComputerCollegeIterator(Department[] departments) { this.departments = departments; } // 判断是否还有下一个元素 @Override public boolean hasNext() { // 判断是数组 if (position >= departments.length || departments[position] == null) { // 没有下一个了 return false; } else { // 还是有下一个 return true; } } @Override public Object next() { Department department = departments[position]; // 后移一位 position += 1; return department; } // 删除的方法空实现 @Override public void remove() { // } } 信息工程学院(生成) package com.atguigu.iterator; import java.util.Iterator; import java.util.List; /** * @author victor * @site https://victorfengming.gitee.io/ * @project design_pattern * @package com.atguigu.iterator * @created 2021-02-08 20:59 * 等你学了数据结构你就会对这个next()十分的敏感 */ public class InfoCollegeIterator implements Iterator { // 信息工程学院是以List方式存放的系的 List departmentList; int index = -1; public InfoCollegeIterator(List departmentList) { this.departmentList = departmentList; } // 判断这个list中还有没有下一个元素 @Override public boolean hasNext() { // 对集合遍历 if (index >= departmentList.size() - 1) { // 说明没有下一个了 return false; } else { // 往后移动 index += 1; return true; } } @Override public Object next() { // 直接返回 这个 return departmentList.get(index); } // 空实现remove方法 @Override public void remove() { } } 到现在为止我们写完了这些 后面的就好写了 College package com.atguigu.iterator; import java.util.Iterator; /** * @author victor * @site https://victorfengming.gitee.io/ * @project design_pattern * @package com.atguigu.iterator * @created 2021-02-08 21:04 */ // 他核心的方法是返回一个 interator public interface College { // 获取名字 public String getName(); // 增加系的方法 public void addDepartment(String name, String desc); // 返回一个迭代器.遍历 public Iterator createIterator(); } 下面我们用2个具体的子类来实现College 计算机学院 package com.atguigu.iterator; import java.util.Iterator; /** * @author victor * @site https://victorfengming.gitee.io/ * @project design_pattern * @package com.atguigu.iterator * @created 2021-02-08 21:11 */ public class ComputerCollege implements College { Department[] departments; // 保存当前数组的对象的个数 int numOfDepartment = 0; // 通过构造器 public ComputerCollege() { departments = new Department[5]; // 初始化数据 addDepartment(\"java分布式专业\",\"面向对象\"); addDepartment(\"php小程序专业\",\"最好的语言\"); addDepartment(\"python大数据专业\",\"数学要好\"); } @Override public String getName() { return \"计算机学院\"; } @Override public void addDepartment(String name, String desc) { // 创建数组 Department department = new Department(name, desc); // 真正的数据是在这里加进去的 departments[numOfDepartment] = department; // 计数器更新,数量+1 numOfDepartment += 1; } @Override public Iterator createIterator() { // 要将自己的department传进去 return new ComputerCollegeIterator(departments); } } 信息学院 package com.atguigu.iterator; import java.util.ArrayList; import java.util.Iterator; import java.util.List; /** * @author victor * @site https://victorfengming.gitee.io/ * @project design_pattern * @package com.atguigu.iterator * @created 2021-02-08 21:28 */ public class InfoCollege implements College { // 不同的地方是哪里呢? //这个地方是list了 List departmentList; //构造器 public InfoCollege() { departmentList = new ArrayList(); addDepartment(\"信息安全专业\",\"IT中的一门\"); addDepartment(\"网络安全专业\",\"网中的一门\"); addDepartment(\"服务器安全专业\",\"机器要安全\"); } @Override public String getName() { return \"信息工程学院\"; } @Override public void addDepartment(String name, String desc) { Department department = new Department(name, desc); // 添加到list中去 departmentList.add(department); } @Override public Iterator createIterator() { // 这个地方直接返回我们这个list就行了 return new InfoCollegeIterator(departmentList); } } 输出类 package com.atguigu.iterator; import java.util.Iterator; import java.util.List; /** * @author victor * @site https://victorfengming.gitee.io/ * @project design_pattern * @package com.atguigu.iterator * @created 2021-02-08 21:33 */ public class OutputImpl { // 吧学院的集合拿到 List collegesList; // public OutputImpl(List collegesList) { this.collegesList = collegesList; } // 遍历所有学院,然后调用printDepartment 输出各个学院的系 public void printCollege() { // 从这个 CollegeList 取出所有的学院 // 直接用迭代器取 // 官方Java中的List已经实现了Iterator接口 Iterator iterator = collegesList.iterator(); // 循环 while (iterator.hasNext()) { // 取出一个学院 College college = iterator.next(); System.out.println(\"---------\"+college.getName()+\"---------\"); // 得到对应的迭代器 printDepartment(college.createIterator()); } } // 输出 学院 输出系 public void printDepartment(Iterator iterator) { // 当 有下一个的时候 while (iterator.hasNext()) { Department d = (Department) iterator.next(); System.out.println(d.getName()); } } } 客户端 package com.atguigu.iterator; import java.util.ArrayList; /** * @author victor * @site https://victorfengming.gitee.io/ * @project design_pattern * @package com.atguigu.iterator * @created 2021-02-08 22:00 */ public class Client { public static void main(String[] args) { System.out.println(\"----------迭代器模式----------\"); // 创建学员 ArrayList collegeList = new ArrayList<>(); ComputerCollege computerCollege = new ComputerCollege(); InfoCollege infoCollege = new InfoCollege(); // collegeList.add(computerCollege); collegeList.add(infoCollege); OutputImpl output = new OutputImpl(collegeList); output.printCollege(); /** * ----------迭代器模式---------- * ---------计算机学院--------- * java分布式专业 * php小程序专业 * python大数据专业 * ---------信息工程学院--------- * 信息安全专业 * 网络安全专业 * 服务器安全专业 * * Process finished with exit code 0 */ } } > > 数据真实是存在ComputerCollege里面,数据传过去,右边只是管迭代 怎么传过去的呢? 当我们创建一个迭代器(ComputerCollegeIterator)的时候 ,我们返回一个迭代器的时候,将这个departments传进去的 这样,无形中就实现了数据共享,设计十分的巧妙 这个在工作中用的很多 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 22:08:26 "},"115_迭代器模式_源码分析.html":{"url":"115_迭代器模式_源码分析.html","title":"源码分析","keywords":"","body":"迭代器模式在JDK-ArrayList集合应用的源码分析类图代码案例我们追一下源码他有一个返回,或者说是得到迭代器对象的方法类图1类图2类图3角色分析说明迭代器模式在JDK-ArrayList集合应用的源码分析 JDK中的ArrayL集合中就使用了迭代器模式 类图 代码 案例 package com.atguigu.jdk; import java.util.ArrayList; import java.util.Iterator; import java.util.List; /** * @author victor * @site https://victorfengming.gitee.io/ * @project design_pattern * @package com.atguigu.jdk * @created 2021-02-08 22:10 */ public class IteratorDemo { public static void main(String[] args) { List a = new ArrayList<>(); a.add(\"jack\"); // 获取到迭代器 Iterator Itr = a.iterator(); while (Itr.hasNext()) { System.out.println(Itr.next()); } /** * jack * * Process finished with exit code 0 */ } } 我们追一下源码 public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable { private static final long serialVersionUID = 8683452581122892189L; 他这个他实现了一个List ,这个list充当了聚合接口的作用,我么这个ArrayList显然是他的具体的子类 我们继续追进去 public interface List extends Collection { // Query Operations /** * Returns an iterator over the elements in this list in proper sequence. * * @return an iterator over the elements in this list in proper sequence */ Iterator iterator(); 在list接口里面,他有一个Iterator方法,在这个接口里面他是一个抽象方法 他有一个返回,或者说是得到迭代器对象的方法 在ArrayList中,有具体的实现 /** * Returns an iterator over the elements in this list in proper sequence. * * The returned iterator is fail-fast. * * @return an iterator over the elements in this list in proper sequence */ public Iterator iterator() { return new Itr(); } 这个ITr就是ArrayList里面的一个内部类 /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator { int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; Itr() {} public boolean hasNext() { return cursor != size; } 类图1 他这个和标准的迭代器模式不一样 因为 ITr已经是ArrayList的内部类了, 所以他能够直接使用Object 类图2 LinkList是链表,也能够迭代 类图3 角色分析说明 内部类Itr充当具体实现迭代器Iterator的类,作为ArrayList 内部类 List就是充当了聚合接口,含有一个iterator()方法,返回一个迭代器对象 ArrayList是实现聚合接口List子类,实现了iterator() Iterator接口系统提供 迭代器模式解决了不同集合(ArrayList,LinkedList) 统一遍历问题 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 22:34:01 "},"116_迭代器模式_使用细节.html":{"url":"116_迭代器模式_使用细节.html","title":"使用细节","keywords":"","body":"迭代器模式的注意事项和细节优点缺点迭代器模式的注意事项和细节 优点 提供一个统一的方法遍历对象,客户不用再考虑聚合的类型,使用一种方法就可以遍历对象 隐藏了聚合的内部结构,客户端遍历聚合的时候只能取到迭代器,而不会知道聚合的具体组成. 提供了一种设计思想,就是一个类应该只有一个引起变化的原因,叫做单一职责原则.在聚合类中,我们把迭代器分开,就是要吧管理对象集合和遍历对象集合的责任分开,这样一来集合改变的话,只是影响到聚合对象.而如果遍历方式改变的话,只影响到了迭代器. 当要展示一组相似对象,或者遍历一组相同对象时,使用,适合使用迭代器模式 缺点 每个聚合对象都要一个迭代器,会生成多个迭代器不好管理类 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 22:41:10 "},"117_观察者模式_天气预报.html":{"url":"117_观察者模式_天气预报.html","title":"天气预报","keywords":"","body":"案例分析天气预报项目需求普通方案获取方式推送方式代码演示CurrentConditionsWeatherData客户端问题分析案例分析 天气预报项目需求 气象站可以将每天测量到的温度,湿度,气压 等等以公告的形式发布出去(比如发布到自己的网站或第三方) 需要设计开放型API,便于其他第三方也能够接入气象站获取数据 提供温度,气压和湿度的接口 测量数据更新时,要能实时的通知给第三方 普通方案 WeatherData类 获取方式 通过对气象站项目的分析,我们可以初步设计出一个WeatherData类 说明: 通过getxxx方法,可以让第三方接入,并得到相关信息 当数据有更新时,气象站通过调用dataChange()去更新数据,当第三方再次获取时,就能得到最新数据,当然也可以推送 气象站的网站他每隔一段时间就调用WeatherData里面的获取数据 推送方式 CurrentConditions(当前的天气情况) 可以理解成是我们气象局的网站 //推送 代码演示 CurrentConditions package com.atguigu.observer; /** * 显示当前天气情况(可以理解成是气象站自己的网站) * @author victor */ public class CurrentConditions { // 温度 private float temperature; // 气压 private float pressure; // 湿度 private float humidity; // 更新天气情况 ,别人来调用,是由于WeatherData来调用,我使用退送模式 public void update(float temperature, float pressure, float humidity) { this.temperature = temperature; this.pressure = pressure; this.humidity = humidity; display(); } // 显示 public void display() { System.out.println(\"---Today mTemperature\"+temperature+\"---\"); System.out.println(\"---Today mPressure\"+pressure+\"---\"); System.out.println(\"---Today mhumidity\"+humidity+\"---\"); } } WeatherData ```javapackage com.atguigu.observer; /** 类是核心 包含最新的天气情况信息 含有CurrentConditions对象 当数据有更新时,就主动的调用CurrentCondition对象的Update()方法 这个方法里面含有一个display的操作,这样他们接入方就看到了最新的信息 @project java_mode @package com.atguigu.observer */ public class WeatherData { private float temperature; // 温度 private float pressure; // 气压 private float humidity; // 湿度 private CurrentConditions currentConditions; public WeatherData(CurrentConditions currentConditions) { this.currentConditions = currentConditions; } public void dataChange() { // 调用我们聚合的currentConditions中的update()方法 currentConditions.update(getTemperature(),getPressure(),getHumidity()); } // 当数据由于更新的时候,就调用setData public void setData(float temperature, float pressure, float humidity, CurrentConditions currentConditions) { this.temperature = temperature; this.pressure = pressure; this.humidity = humidity; // 调用dataChange,将最新的信息推送给接入方 currentCondition dataChange(); } public float getTemperature() { return temperature; } public void setTemperature(float temperature) { this.temperature = temperature; } public float getPressure() { return pressure; } public void setPressure(float pressure) { this.pressure = pressure; } public float getHumidity() { return humidity; } public void setHumidity(float humidity) { this.humidity = humidity; } public CurrentConditions getCurrentConditions() { return currentConditions; } public void setCurrentConditions(CurrentConditions currentConditions) { this.currentConditions = currentConditions; } } ``` 客户端 设置天气 package com.atguigu.observer; /** * ClassName: * Description: * Date: 2021-02-09 9:43 * @project java_mode * @package com.atguigu.observer */ public class Client { public static void main(String[] args) { System.out.println(\"----观察者模式----\"); // 创建一个接入方 CurrentConditions currentConditions = new CurrentConditions(); // 创建 weatherData对象 ,并将接入方currentConditions 传递到WeatherData中 WeatherData weatherData = new WeatherData(currentConditions); // 更新天气信息 weatherData.setData(30,150,40); /** * ----观察者模式---- * ---Today mTemperature30.0--- * ---Today mPressure150.0--- * ---Today mhumidity40.0--- * * Process finished with exit code 0 */ } } 更新天气 package com.atguigu.observer; /** * ClassName: * Description: * Date: 2021-02-09 9:43 * @project java_mode * @package com.atguigu.observer */ public class Client { public static void main(String[] args) { System.out.println(\"----观察者模式----\"); // 创建一个接入方 CurrentConditions currentConditions = new CurrentConditions(); // 创建 weatherData对象 ,并将接入方currentConditions 传递到WeatherData中 WeatherData weatherData = new WeatherData(currentConditions); // 更新天气信息 weatherData.setData(30,150,40); // 天气情况变化 System.out.println(\"----天气情况变----\"); weatherData.setData(40, 160, 20); /** *----观察者模式---- * ---Today mTemperature30.0--- * ---Today mPressure150.0--- * ---Today mhumidity40.0--- * ----天气情况变---- * ---Today mTemperature40.0--- * ---Today mPressure160.0--- * ---Today mhumidity20.0--- * * Process finished with exit code 0 */ } } 问题分析 其他第三方接入气象站获取数据的问题 无法在运行时动态的添加第三方(比如新浪网站) 违反了OCP原则 => 观察者模式 那就要在创建一个类似CurrentConditions.java的类为新浪 然后在WeatherData加入新的第三方 不符合我们的OCP原则 // 在WeatherData中,当增加一个第三方,都需要创建一个对应的第三方的公告板对象,并加入到dataChange,不利于维护,也不是动态加入 public void dataChange(){ currentConditions.update(getTemperature(),getPressure(),getHumidity()) } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-09 18:28:42 "},"119_观察者模式_工作原理.html":{"url":"119_观察者模式_工作原理.html","title":"工作原理","keywords":"","body":"观察者模式(Observer)原理观察者模式(Observer)原理 观察者模式类似订牛奶业务 奶站/气象局: Subject 用户/第三方网站:Observe Subject:等级注册,移除和通知 registerObserver注册 removeObsever移除 notifyObservers()通知所有的注册用户,根据不同的需求,可以是更新数据,让用户来取,也可能是实施推送,看具体需求定 Observer:接收输入 观察者模式: 对象之间多对一依赖的一种设计方案,被依赖的对象为Subject, 依赖的对象为Observer,Subject通知Observer变化, 比如这里的奶站是Subject,是一的一方. 用户使Observer,是多的一方. new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-09 18:28:42 "},"120_观察者模式_代码实践.html":{"url":"120_观察者模式_代码实践.html","title":"代码实践","keywords":"","body":"代码实践原理类图codeSubjectObserverCurrentConditionsWeatherData客户端百度客户端代码实践 原理类图 code 老师个大傻X,他tm起名和系统内置的Observer一样的接口,最后tm类导入乱了,傻B 改进方案 Observer => Observer2 Subject package com.atguigu.observer.improve; // 让这个WeathreData来实现 public interface Subject { public void registerObserver(Observer2 o); public void removeObserver(Observer2 o); public void notifyObservers(); } Observer package com.atguigu.observer.improve; /** * ClassName: 观察者接口,由观察者来实现 * * @project java_mode * @package com.atguigu.observer.improve */ public interface Observer2 { public void update(float temperature, float pressure, float humidity); } CurrentConditions 这个和前面的一样就行了 package com.atguigu.observer.improve; import java.util.Observable; import java.util.Observer; /** * ClassName: * Description: * Date: 2021-02-09 10:09 * * * @author victor * @project java_mode * @package com.atguigu.observer.improve */ public class CurrentConditions implements Observer2 { // 温度 private float temperature; // 气压 private float pressure; // 湿度 private float humidity; // 更新天气情况 ,别人来调用,是由于WeatherData来调用,我使用退送模式 public void update(float temperature, float pressure, float humidity) { this.temperature = temperature; this.pressure = pressure; this.humidity = humidity; display(); } // 显示 public void display() { System.out.println(\"---Now mTemperature\"+temperature+\"---\"); System.out.println(\"---Now mPressure\"+pressure+\"---\"); System.out.println(\"---Now mhumidity\"+humidity+\"---\"); } } WeatherData package com.atguigu.observer.improve; import java.util.ArrayList; /** * 类是核心 * 1. 包含最新的天气情况信息 * 2. 含有观察者集合,使用ArrayList管理 * 3. 当数据有更新时,就主动的调用ArrayList * 通知所有的(接入方)就看到最新的信息 * * @project java_mode * @package com.atguigu.observer */ public class WeatherData implements Subject { private float temperature; // 温度 private float pressure; // 气压 private float humidity; // 湿度 // 观察者集合 private ArrayList observers; private CurrentConditions currentConditions; public WeatherData() { observers = new ArrayList(); } public void dataChange() { notifyObservers(); } // 当数据由于更新的时候,就调用setData public void setData(float temperature, float pressure, float humidity) { this.temperature = temperature; this.pressure = pressure; this.humidity = humidity; // 调用dataChange,将最新的信息推送给接入方 currentConditions dataChange(); } // 注册一个观察者 @Override public void registerObserver(Observer2 o) { observers.add(o); } // 移除一个观察者 @Override public void removeObserver(Observer2 o) { if (observers.contains(o)) { observers.remove(o); } } //遍历所有的观察者,并通知 @Override public void notifyObservers() { for (int i = 0; i getObservers() { return observers; } public void setObservers(ArrayList observers) { this.observers = observers; } public CurrentConditions getCurrentConditions() { return currentConditions; } public void setCurrentConditions(CurrentConditions currentConditions) { this.currentConditions = currentConditions; } } 客户端 package com.atguigu.observer.improve; /** * ClassName: * Description: * Date: 2021-02-09 10:33 * @author yufengming * @project java_mode * @package com.atguigu.observer.improve */ public class Client { public static void main(String[] args) { // 创建一个WeatherData WeatherData weatherData = new WeatherData(); // 创建观察者 CurrentConditions currentConditions = new CurrentConditions(); // 注册到weatherData weatherData.registerObserver(currentConditions); //测试 System.out.println(\"通知各个观察者,看看信息\"); weatherData.setData(10f,101f,20.3f); /** * 通知各个观察者,看看信息 * ---Now mTemperature10.0--- * ---Now mPressure101.0--- * ---Now mhumidity20.3--- * * Process finished with exit code 0 */ } } 这样写的扩展性质就会十分好 比如:我现在要加一个百度(新的观察者) 百度 package com.atguigu.observer.improve; /** * ClassName: * Description: * Date: 2021-02-09 10:36 * @author yufengming * @project java_mode * @package com.atguigu.observer.improve */ public class BaiduSite implements Observer2{ // 温度 private float temperature; // 气压 private float pressure; // 湿度 private float humidity; // 更新天气情况 ,别人来调用,是由于WeatherData来调用,我使用退送模式 public void update(float temperature, float pressure, float humidity) { this.temperature = temperature; this.pressure = pressure; this.humidity = humidity; display(); } // 显示 public void display() { System.out.println(\"----baidu.com----\"); System.out.println(\"---百度: mTemperature\"+temperature+\"---\"); System.out.println(\"---百度: mPressure\"+pressure+\"---\"); System.out.println(\"---百度: mhumidity\"+humidity+\"---\"); } } 客户端 package com.atguigu.observer.improve; /** * ClassName: * Description: * Date: 2021-02-09 10:33 * @author yufengming * @project java_mode * @package com.atguigu.observer.improve */ public class Client { public static void main(String[] args) { // 创建一个WeatherData WeatherData weatherData = new WeatherData(); // 创建观察者 CurrentConditions currentConditions = new CurrentConditions(); BaiduSite baiduSite = new BaiduSite(); // 注册到weatherData weatherData.registerObserver(currentConditions); weatherData.registerObserver(baiduSite); //测试 System.out.println(\"通知各个观察者,看看信息\"); weatherData.setData(10f,101f,20.3f); /** * 通知各个观察者,看看信息 * ---Now mTemperature10.0--- * ---Now mPressure101.0--- * ---Now mhumidity20.3--- * ----baidu.com---- * ---百度: mTemperature10.0--- * ---百度: mPressure101.0--- * ---百度: mhumidity20.3--- * * Process finished with exit code 0 */ } } 这么写就很灵活,还可以去掉Current观察者,随时 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"121_观察者模式_源码分析.html":{"url":"121_观察者模式_源码分析.html","title":"源码分析","keywords":"","body":"观察者模式在JDK的源码分析类图代码演示模式角色分析观察者模式在JDK的源码分析 JDK的Observable中使用了观察者模式i 类图 代码演示 public class Observable { private boolean changed = false; private Vector obs; /** Construct an Observable with zero Observers. */ Observable里面实现了相关方法 /** * Adds an observer to the set of observers for this object, provided * that it is not the same as some observer already in the set. * The order in which notifications will be delivered to multiple * observers is not specified. See the class comment. * * @param o an observer to be added. * @throws NullPointerException if the parameter o is null. */ public synchronized void addObserver(Observer o) { if (o == null) throw new NullPointerException(); if (!obs.contains(o)) { obs.addElement(o); } } /** * Deletes an observer from the set of observers of this object. * Passing null to this method will have no effect. * @param o the observer to be deleted. */ public synchronized void deleteObserver(Observer o) { obs.removeElement(o); } /** * If this object has changed, as indicated by the * hasChanged method, then notify all of its observers * and then call the clearChanged method to * indicate that this object has no longer changed. * * Each observer has its update method called with two * arguments: this observable object and null. In other * words, this method is equivalent to: * * notifyObservers(null) * * @see java.util.Observable#clearChanged() * @see java.util.Observable#hasChanged() * @see java.util.Observer#update(java.util.Observable, java.lang.Object) */ public void notifyObservers() { notifyObservers(null); } 不同的是,他没有去实现接口,而是把这个类和接口放在了一起 他直接就是一个类, 模式角色分析 Observable的作用和地位等价于我们前面讲过Subject Observable是类,不是接口,类中已经实现了核心的方法,即管理Observer的方法,add.. delete.. notify... Observer的作用和地位等价于我们其那面讲过的Observer Observable和Observer的使用方法和其那面讲过的一样,只是Observable,是一个类,踏实通过继承来实现观察者模式的 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-09 18:28:42 "},"122_观察者模式_内容梳理.html":{"url":"122_观察者模式_内容梳理.html","title":"内容梳理","keywords":"","body":"观察者模式内容梳理观察者模式不是很难,这里就不梳理了观察者模式内容梳理 观察者模式不是很难,这里就不梳理了 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-09 18:28:42 "},"123_终结者模式_智能家庭.html":{"url":"123_终结者模式_智能家庭.html","title":"智能家庭","keywords":"","body":"智能家庭管理问题智能家庭项目:传统方案类图(租房子)问题改进传统的方式的问题分析智能家庭管理问题 智能家庭项目: 智能家庭包括各种设备,闹钟,咖啡机,电视机,窗帘 等 主任要看电视时,各个设备可以协同工作,自动完成看电视的准备工作,比如流程为: 闹铃响起 => 咖啡机开始做咖啡 => 窗帘自动落下 => 电视机开始播放 传统方案 类图(租房子) 问题 比如你要租房,你本来和Master弹好了 房主HouseMaster说不行,我得问一下我的Wife, wife说不行,我要问一下我的Father, Father说不行我得问一下我的Brother 然后还要一层一层的返回 这样呢,这个流程就很麻烦,现在怎么改进呢 改进 这样,在他们之间有一个中介来维护 换而言之,他们直接也不要有关系了,这回 这样可以不让系统之间进行交流 你这样,不要让子系统相互调用,否则就会相当的麻烦了 终结者模式利用他比较特殊的身份,减少子系统之间的耦合 传统的方式的问题分析 当各电器对象有多种状态改变的时候,相互之间的调用关系会比较复杂 各个电器对象彼此联系,你中有我,我中有你,不利于松耦合 各个电器之间所传递的消息(参数),容易混乱 当系统增加一个新的电器对象时候,或者执行流程改变时,代码的可维护性,扩展性,都不理想 => 考虑终结者模式 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-09 18:28:42 "},"124_终结者模式_原理分析.html":{"url":"124_终结者模式_原理分析.html","title":"原理分析","keywords":"","body":"终结者模式基本介绍MVC原理类图终结者原理图对于原理类图的说明终结者模式基本介绍 终结者模式(Mediator Pattern),用一个终结者对象来封装一系列的对象交互. 终结者是各个对象不需要显示地相互引用,从而使其耦合松散,而且可以独立地改变他们之间的交互 终结者模式属于行为型模式,使代码易于维护 比如MVC模式,C(Controller控制器)是M(Model模型)和V(View视图)的终结者,在前后端交互时起到了中间人的作用.MVC原理类图 Controller就是终结者 终结者原理图 ConcreteColleague还可能有第二个 ConcreteColleague 是怎么把自己的实例放入到这个HashMap里面去的呢 终结者模式采取了一个巧妙的方法 他在创建自己的时候,创建一个具体的同事类的时候,就把自己放在了ConcreteMediator的集合里面去了 他会用到这个Mediator ConcreteColleague在构造器中,在构造自己的时候,它会把这个Mediator拿到 通过Mediator调用他的相关的方法,就把他放在了这个具体的中介类的HashMap里面去了 客户端调用 对于原理类图的说明 Mediator就是抽象终结者,定义了同事对象到终结者对象的接口 Colleague 是抽象同事类(后面我们去管理的子系统的父类,比如电器,具体的人) ConcreteMediator 具体的终结者对象,实现抽象方法,他需要知道所有的具体的同事类,即他会以一个集合来管理HashMap,并接受某个同事对象消息,完成相应的任务 ConcreteColleague 具体的同事类,会有很多,每个同事只知道自己的行为,而不了解其他同事类的情况行为(方法),但是它们都含有(依赖)终结者对象. 精髓: ConcreteColleague和ConcreteColleague2 之间么有关系,实现解耦 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-09 18:28:42 "},"125_终结者模式_代码实践.html":{"url":"125_终结者模式_代码实践.html","title":"代码实践","keywords":"","body":"终结者模式应用案例类图终结者模式-智能家庭操作流程部分代码一句话终结者模式应用案例 类图 终结者模式-智能家庭操作流程 创建ConcreteMediator对象 创建各个同事类Alarm,CoffeeMachine,TV... 在创建同事类对象的时候,就直接通过构造器,加入到colleagueMap 同时类对象,可以调用sendMessage,最终会去调用ConcreteMediator的getMessage()方法 getMessage()会根据接收到的同事对象发出来的消息来协调调用其他的同事对象,完成任务 可以看到getMessage()是核心方法,完成相应的任务 这个案例的代码就太多了 把这个思想理解就行了 咱们就不写了 部分代码 package com.atguigu.mediator; /** * ClassName: * Description: * Date: 2021-02-09 13:59 * * * @author yufengming * @project java_mode * @package com.atguigu.mediator */ public abstract class Mediator { // 将一个终结者对象,加入到集合中 public abstract void Register(String colleagueName, Colleague colleague); // 接收消息,具体的同事对象发出的 public abstract void GetMessage(int stateChange, String colleague); public abstract void SendMessage(); } package com.atguigu.mediator; /** * ClassName: * Description: * Date: 2021-02-09 13:57 * * * @author yufengming * * @project java_mode * @package com.atguigu.mediator */ public class Curtains extends Colleague{ public Curtains(Mediator mediator, String name) { super(mediator, name); mediator.Register(name, this); } @Override public void SendMessage(int stateChange) { this.GetMediator().GetMessage(stateChange, this.name); } public void UpCurtains() { System.out.println(\"I am holding Up Curtains!\"); } } 一句话 不要让 那些 类之间有关系 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-09 18:28:42 "},"126_终结者模式_内容梳理.html":{"url":"126_终结者模式_内容梳理.html","title":"内容梳理","keywords":"","body":"终结者模式注意事项终结者模式注意事项 多个类相互耦合,会形成网状结构,使用终结者模式将网站结构分离为星型结构,进行解耦 减少类之间的依赖,降低了耦合,符合迪米特法则 终结者承担了较多的责任,一旦和终结者出现了问题,整个系统就会受到影响 如果设计不当,终结者对象本身变得过于复杂,这点在实际使用时,要特别注意 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-09 18:28:42 "},"127_备忘录模式_游戏角色.html":{"url":"127_备忘录模式_游戏角色.html","title":"游戏角色","keywords":"","body":"案例游戏角色状态恢复问题传统设计方案传统状态问题分析案例 游戏角色状态恢复问题 游戏角色有攻击力和防御力,在大战Boss前保存自身的状态(攻击力和防御力),当大战Boss攻击力和防御力下降,从备忘录对象恢复到大战前的状态 传统设计方案 传统状态问题分析 一个对象,就对应一个保存对象状态的对象,这样当我们游戏的对象很多的时候,不利于管理,开销也很大 传统的方式是简单地做备份,new出另外一个对象出来,再把需要备份的数据放到这个新对象,但这就暴露了对象内部的细节 解决方案 => 当当当当~ 备忘录模式 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-09 18:28:42 "},"128_备忘录模式_工作原理.html":{"url":"128_备忘录模式_工作原理.html","title":"工作原理","keywords":"","body":"备忘录模式基本介绍类图代码mementoOriginatorCaretaker客户端对原理类图的说明备忘录模式 基本介绍 备忘录模式(Memento Pattern)在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态.这样以后就可将该对象恢复到原先保存的状态 可以这里理解备忘录模式: 现实生活中的备忘录是用来记录某些要去做的事情,或者是记录已经达成的共同意见的事情,以防忘记了.而在软件层面,备忘录模式有着相同的含义,备忘录对象主要用来记录一个对象的某种状态,或者某些数据,当要丛回退时,可以从备忘录对象里获取原来的数据进行恢复操作 备忘录模式术语行为型模式 类图 代码 memento package com.atguigu.memento.theory; public class Memento { private String state; // 构造器 public Memento() { } public Memento(String state) { this.state = state; } public String getState() { return state; } public void setState(String state) { this.state = state; } } Originator package com.atguigu.memento.theory; public class Originator { private String state;// 状态信息 public String getState() { return state; } public void setState(String state) { this.state = state; } // 编写一个方法,可以保存一个状态对象 Memento // 因此编写一个方法,返回Memento public Memento saveStateMemento() { return new Memento(state); } // 通过备忘录对象,恢复状态 public void getStateFromMemento(Memento memento) { // 这个状态返回 // 这接赋值给 state = memento.getState(); } } Caretaker package com.atguigu.memento.theory; import java.util.ArrayList; import java.util.List; public class Caretaker { // 在List集合中有很多备忘录对象 private List mementoList = new ArrayList(); public void add(Memento memento) { mementoList.add(memento); } /// 获取到第index个Originator的备忘录对象(即保存的状态) public Memento get(int index) { return mementoList.get(index); } } 客户端 package com.atguigu.memento.theory; /** * ClassName: * Description: * Date: 2021-02-09 14:36 * @project java_mode * @package com.atguigu.memento */ public class Client { public static void main(String[] args) { System.out.println(\"----备忘录模式----\"); // Originator originator = new Originator(); Caretaker caretaker = new Caretaker(); originator.setState(\"状态#1~攻击力100\"); // 保存了当前的状态 caretaker.add(originator.saveStateMemento()); originator.setState(\"状态#2~攻击力80\"); caretaker.add(originator.saveStateMemento()); originator.setState(\"状态#3~攻击力50\"); // 希望恢复到状态1 System.out.println(\"当前的状态是=\"+originator.getState()); // 得到第一个状态 originator.getStateFromMemento(caretaker.get(0)); // 将originator 的状态 恢复到状态1 System.out.println(\"恢复到状态1\\n当前的状态是=\"+originator.getState()); System.out.println(\"------------------\"); /** * ----备忘录模式---- * 当前的状态是=状态#3~攻击力50 * 恢复到状态1 * 当前的状态是=状态#1~攻击力100 * ------------------ * * Process finished with exit code 0 */ } } 这个String 的状态类型,可以扩展的更加复杂 对原理类图的说明 备忘录模式的角色及职责 originator: 对象(需要保存状态的对象) Memento: 备忘录对象,负责保存好记录,即Originator内部状态 Caretaker:守护者对象,负责保存多个备忘录对象,使用集合管理,提高效率 说明: 如果希望保存多个originator对象的不同时间的状态,也可以,只需要HashMap 这个就自己扩展吧! new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-09 18:28:42 "},"129_备忘录模式_代码实践.html":{"url":"129_备忘录模式_代码实践.html","title":"代码实践","keywords":"","body":"游戏角色恢复状态实例1. 应用实例要求2. 思路分析和图解(类图)3. 代码实现MementoCaretakerGameRole客户端游戏角色恢复状态实例 1. 应用实例要求 游戏角色有攻击力和防御力,在大战Boss前身保存自身的状态(攻击力和防御力),当大战Boss后攻击力和防御力下降,从备忘录对象恢复到大战前的状态 2. 思路分析和图解(类图) > 3. 代码实现 Memento package com.atguigu.memento.game; /** * ClassName: * Description: * Date: 2021-02-09 15:16 * @project java_mode * @package com.atguigu.memento.game */ public class Memento { //攻击力 private int vit; //防御力 private int def; public Memento(int vit, int def) { this.vit = vit; this.def = def; } public int getVit() { return vit; } public void setVit(int vit) { this.vit = vit; } public int getDef() { return def; } public void setDef(int def) { this.def = def; } } Caretaker package com.atguigu.memento.game; import java.util.ArrayList; import java.util.HashMap; /** * ClassName:守护者对象,保存游戏角色的状态 * @project java_mode * @package com.atguigu.memento.game */ public class Caretaker { // 如果只保存一次状态 private Memento memento; // // 对GameRole保存多次状态 // private ArrayList mementos; // // 对多个游戏角色保存多个状态 // private HashMap> rolesMementos; public Memento getMemento() { return memento; } public void setMemento(Memento memento) { this.memento = memento; } } GameRole package com.atguigu.memento.game; /** * ClassName: * Description: * Date: 2021-02-09 15:20 * @project java_mode * @package com.atguigu.memento.game */ public class GameRole { private int vit; private int def; // 创建一个Memento 通你这个游戏角色 当前的状态得到一个 public Memento createMemento() { return new Memento(vit, def); } // 从备忘录对象,恢复GameRole'状态 public void recoverGameRoleFromMemento(Memento memento) { this.vit = memento.getVit(); this.def = memento.getDef(); } // 显示当前游戏角色的状态 public void display() { System.out.println(\"游戏角色当前的攻击力:\"+this.vit); System.out.println(\"游戏角色当前的防御力:\"+this.def); } public int getVit() { return vit; } public void setVit(int vit) { this.vit = vit; } public int getDef() { return def; } public void setDef(int def) { this.def = def; } } 客户端 package com.atguigu.memento.game; /** * ClassName: * Description: * Date: 2021-02-09 15:25 * @project java_mode * @package com.atguigu.memento.game */ public class Client { public static void main(String[] args) { System.out.println(\"----备忘录模式--------\"); // 创建游戏角色 GameRole gameRole = new GameRole(); gameRole.setVit(100); gameRole.setDef(100); System.out.println(\"----和boss大战之前的状态----\"); gameRole.display(); // 把当前的状态保存caretaker Caretaker caretaker = new Caretaker(); caretaker.setMemento(gameRole.createMemento()); // System.out.println(\"和boss开始大战~~~\"); gameRole.setVit(30); gameRole.setDef(30); System.out.println(\"大战之后~~~\"); gameRole.display(); System.out.println(\"大战只后,使用备忘录对象恢复到大战之前\"); gameRole.recoverGameRoleFromMemento(caretaker.getMemento()); System.out.println(\"恢复后的状态:\"); gameRole.display(); /** * ----备忘录模式-------- * ----和boss大战之前的状态---- * 游戏角色当前的攻击力:100 * 游戏角色当前的防御力:100 * 和boss开始大战~~~ * 大战之后~~~ * 游戏角色当前的攻击力:30 * 游戏角色当前的防御力:30 * 大战只后,使用备忘录对象恢复到大战之前 * 恢复后的状态: * 游戏角色当前的攻击力:100 * 游戏角色当前的防御力:100 * * Process finished with exit code 0 */ } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-09 18:28:42 "},"130_备忘录模式_追事项.html":{"url":"130_备忘录模式_追事项.html","title":"追事项","keywords":"","body":"备忘录模式的追事项和细节备忘录模式的追事项和细节 给用户提供了 一种可以恢复状态的机制,可以使用户能够比较方便地回到某个历史的状态 实现了信息的封装,使得用户不需要关心状态的保存细节 如果类的成员变量过多,势必会占用比较大的资源,而且每一次保存都会消耗一定的内存,这个需要注意 适用的应用场景: 后悔药 打游戏时的存档 Windows里的ctrl+z IE中的后退 数据库的事务管理 为了节约内存,备忘录模式可以和原型模式配合使用 那还不如叫做\"后悔药模式\"呢 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-09 18:28:42 "},"131_解释器模式_计算求值.html":{"url":"131_解释器模式_计算求值.html","title":"计算求值","keywords":"","body":"案例计算求值传统方案解决四则运算问题分析案例 计算求值 通过解释器模式来实现四则运算,如果a+b-c的值,具体要求 先输入表达式的形式,比如a+b+c-d+e,要求表达式的字母不能重复 在分别输入a,b,c,d,e的值 最后求出结果: 如图 好家伙,这回强行让我们用这个模式了 玩不起他 传统方案解决四则运算问题分析 编写一个方法,接收表达式的形式,然后根据用户输入的数值进行解析,得到结果 问题分析: 如果加入新的运算符,比如 * / (等等,不利于扩展,另外让一个方法来解析会造成程序结构混乱,不够清晰 解决方案: 可以考虑使用解释器模式,即:表达式 -> 解释器(可以有多种) -> 结果 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-09 18:48:16 "},"132_解释器模式_原理解析.html":{"url":"132_解释器模式_原理解析.html","title":"原理解析","keywords":"","body":"解释器模式基本介绍原理类图对原理类图的说明解释器模式基本介绍 在编译原理中,一个算术表达式通过词法分析器形成词法单元,而后这些词法单元再通过语法分析器构建语法分析树,最终形成一颗抽象的语法分析树.这里的词法分析器和语法分析器都可以看做是解释器 解释器模式(Interpreter pattern):是指给定一个语言表达式)定义它的文法的一种表示,并定义一个解释器,使用该解释器来解释语言中的句子(表达式) 应用场景 应用可以将一个需要解释执行的语言中的句子表示为一个抽象语法树 一些重复出现的问题可以用一种简单的语言来表达 一个简单语法需要解释的场景 这样的例子还有,比如编译器,运算表达式计算,正则表达式,机器人等 原理类图 对原理类图的说明 解释器模式角色及职责 Context:是环境角色,含有解释器之外的全局信息 AbstractExpression: 抽象表达式,声明一个抽象的解释操作,这个方法为抽象语法树中所有的节点所共享 TerminalExpression: 为终结符表达式,实现与文法中的终结符相关的解释操作 NonTerminalExpression: 为非终结符表达式,实现与文法中的非终结符实现解释操作. 说明: 输入Context 和 TerminalExpression 信息通过Client输入即可. 我疯了 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-10 21:20:21 "},"133_解释器模式_代码实践.html":{"url":"133_解释器模式_代码实践.html","title":"代码实践","keywords":"","body":"计算求值原理类图代码实践ExpressionSymbolExpressionVarExpressionAddExpressionSubExpressionCalculatorClient计算求值 原理类图 代码实践 Expression package com.atguigu.interpreter; import java.util.HashMap; /** * 抽象类表达式,通过HashMap键值对,可以获取到变量的值 * * @author victor */ public abstract class Expression { // a+b-c // 解释公式和数值,key就是公式(表达式),参数[a,b,c],value就是具体值 // HashMap {a=10,b=20} public abstract int interpreter(HashMap var); } SymbolExpression package com.atguigu.interpreter; import java.util.HashMap; /** * ClassName: * Description: 抽象 的运算符号解析器,这里每个运算符号,都只和自左右两个数字有关系,但左右两个数字有可能也是一个解析的结果,无论何种类型,都是Expression类的实现类 * @project java_mode * @package com.atguigu.interpreter */ public class SymbolExpression extends Expression{ protected Expression left; protected Expression right; public SymbolExpression(Expression left, Expression right) { this.left = left; this.right = right; } /** * 因为SymbolExpression是让其子类来实现, * 因此interpreter是一个默认实现 * @param var * @return */ @Override public int interpreter(HashMap var) { return 0; } } VarExpression package com.atguigu.interpreter; import java.util.HashMap; /** * 变量的解释器 * @author victor */ public class VarExpression extends Expression{ private String key; public VarExpression(String key) { this.key = key; } // var就是{a=10,b=20} // interpreter 根据变量的名称,返回对应的值 @Override public int interpreter(HashMap var) { return var.get(this.key); } } AddExpression package com.atguigu.interpreter; import java.util.HashMap; /** * ClassName: * Description: 加法解释器 * @project java_mode * @package com.atguigu.interpreter */ public class AddExpression extends SymbolExpression{ public AddExpression(Expression left, Expression right) { super(left, right); } // 处理相加 // var仍然是{a=10,b=20}... @Override public int interpreter(HashMap var) { // super.left.interpreter(var): 返回左边表达式对应的值 // super.right.interpreter(var):返回右边表达式对应的值 return super.left.interpreter(var)+super.right.interpreter(var); // 你不要纠结他是怎么程序中怎么算出来的 // 体会设计模式,这个程序本身复杂,但是光看设计模式不复杂 } } SubExpression package com.atguigu.interpreter; import java.util.HashMap; /** * ClassName: * Description: * @project java_mode * @package com.atguigu.interpreter */ public class SubExpression extends SymbolExpression{ public SubExpression(Expression left, Expression right) { super(left, right); } /** * 求出left和right表达式相减后的结果 * @param var * @return */ @Override public int interpreter(HashMap var) { return super.left.interpreter(var)-super.right.interpreter(var); } } Calculator package com.atguigu.interpreter; import java.util.HashMap; import java.util.Stack; /** * ClassName: * Description: * @project java_mode * @package com.atguigu.interpreter */ public class Calculator { // 定义表达式 private Expression expression; // 构造函数传参,并解析 public Calculator(String expStr) { // expStr = a+b // 安排运算先后顺序 Stack stack = new Stack<>(); // 表达式拆分成字符数组 char[] charArray = expStr.toCharArray(); Expression left = null; Expression right = null; // 遍历我么的字符数组,即遍历 [a,+,b] // 针对不同的情况做响应处理 for (int i = 0; i var) { // 最后将表达式 a+b 和var 绑定 {a=10,b=20} // 然后传递给Expression的interpreter进行解释执行 return this.expression.interpreter(var); } } Client package com.atguigu.interpreter; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.HashMap; /** * ClassName: * Description: * @project java_mode * @package com.atguigu.interpreter */ public class Client { public static void main(String[] args) throws IOException { String expStr = getExpStr(); // a+b HashMap var = getValue(expStr); Calculator calculator = new Calculator(expStr); System.out.println(\"运算结果\"+expStr+\"=\"+calculator.run(var)); } /** * 获得表达式 * @return * @throws IOException */ public static String getExpStr() throws IOException { System.out.println(\"请输入表达式;:\"); return(new BufferedReader(new InputStreamReader(System.in))).readLine(); } public static HashMap getValue(String expStr) throws IOException { HashMap map = new HashMap<>(); for (char ch : expStr.toCharArray()) { if (ch != '+' && ch != '-') { // 这里看不到了 } } // todo 这里有若干行代码省略了 // todo 这里有若干行代码省略了 // todo 这里有若干行代码省略了 return map; } } 他这种设计模式的把这个表达式分成了2中类型 要结合业务逻辑 这个模式和语法和一些解析有关,这个模式用的不是那么那啥 这个模式他比较容易扩展 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-10 21:20:21 "},"134_解释器模式_源码分析.html":{"url":"134_解释器模式_源码分析.html","title":"源码分析","keywords":"","body":"上代码类图说明上代码 类图 说明 Expression接口表达式接口 下面有不同的实现类,比如SpelExpression,或者CompositeStringExpression. 使用上海,根据你创建的不同的parse对象,返回对应的Expression表达式对象 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-10 21:20:21 "},"135_解释器模式_注意事项.html":{"url":"135_解释器模式_注意事项.html","title":"注意事项","keywords":"","body":"解释器模式的注意事项和细节解释器模式的注意事项和细节 当有一个语言需要解释执行,可将该语言中的句子表示为一个抽象语法树,就可以考虑使用解释器模式,让程序具有良好的扩展性 应用场景:编译器,运算表达式计算,正则表达式,机器人等 使用解释器可能带来的问题: 解释器模式会引起类膨胀,解释器模式采用递归调用方法,将会导致调试非常复杂,效率可能降低. 归根结底几十解释器他面对的问题就比较复杂 所以在开发中,你别动不动就用解释器模式 你如果学正则表达式都费劲,你还想用解释器来解释好正则,那白扯啊 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-10 21:20:21 "},"136_状态模式_先看原理.html":{"url":"136_状态模式_先看原理.html","title":"先看原理","keywords":"","body":"App抽奖活动问题状态模式基本介绍原理类图对原理类图的说明-姐(状态模式的角色及其职责)App抽奖活动问题 请编写程序完成App抽奖活动 具体要求如下: 加入每参加一次这个活动要扣除用户50积分,中奖概率是10% 奖品数量固定,抽完就不能抽奖 活动有4个状态,可以抽奖,不能抽奖,发放奖品和奖品领完 活动的四个状态转换关系图如下: 状态模式基本介绍 状态模式(State Pattern): 它主要用来解决对象在多种状态装换时,需要对外输出不同的行为的问题.状态和行为时一一对应的,状态之间可以相互转换 当一个对象的内在状态改变时,允许改变其行为,这个对象看起来像是改变了其类 这个有点像verilog中的状态机 原理类图 对原理类图的说明-姐(状态模式的角色及其职责) Context类为环境角色,用于维护State实例,这个实例定义当前的状态 State是抽象状态角色,定义一个接口封装与Context的一个特点相关行为 ConcreteState具体的状态角色,每个子类实现一个与Context的一个状态相关行为. new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"137_状态模式_抽奖活动.html":{"url":"137_状态模式_抽奖活动.html","title":"抽奖活动","keywords":"","body":" new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"138_状态模式_借贷平台.html":{"url":"138_状态模式_借贷平台.html","title":"借贷平台","keywords":"","body":" new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 17:27:51 "},"139_状态模式_注意事项.html":{"url":"139_状态模式_注意事项.html","title":"注意事项","keywords":"","body":"模式简介定义模式中的角色状态模式的类图模式简介 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类，(State Pattern)是设计模式的一种，属于行为模式。 定义 (源于Design Pattern)：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。 状态模式主要解决的是当控制一个对象状态的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。 模式中的角色 　　1 上下文环境（Context）：它定义了客户程序需要的接口并维护一个具体状态角色的实例，将与状态相关的操作委托给当前的Concrete State对象来处理。 　　2 抽象状态（State）：定义一个接口以封装使用上下文环境的的一个特定状态相关的行为。 　　3 具体状态（Concrete State）：实现抽象状态定义的接口。 状态模式的类图 这里来看看状态模式的标准代码； 首先我们先定义一个State抽象状态类，里面定义了一个接口以封装 与Context的一个特定状态相关的行为； /** * 抽象状态类 * @author gh * */ public abstract class State { public abstract void Handle(Context context); } 接着再去声明一个ConcreteState具体状态类，每一个子类实现一个与Context的一个状态的相关的行为。 public class ConcreteStateA extends State{ @Override public void Handle(Context context) { context.setState(new ConcreteStateB()); //设置A的下一个状态是B } } class ConcreteStateB extends State{ @Override public void Handle(Context context) { context.setState(new ConcreteStateA()); //设置B的下一个状态是A } } Context类，维护一个ConcreteState子类的实例，这个实例定义当前的状态 /** * 定义当前的状态 * @author gh * */ public class Context { State state; public Context(State state) { //定义Context的初始状态 super(); this.state = state; } public State getState() { return state; } public void setState(State state) { this.state = state; System.out.println(\"当前状态为\"+state); } public void request(){ state.Handle(this); //对请求做处理并且指向下一个状态 } } 提到状态模式，让我想到了工作流，工作流就是控制一个一个的节点状态来实现节点的跳转，最后来控制流程。 如果上面发起了一个请假流程，这个时候第一个节点就是部门领导审核，部门领导审核通过会继续往下走，如果不通过那么有两种状态，一种是直接驳回请求，领导说，项目最近很急，任何人都不能请假，还有一种是你写的请假申请单不对，要退回整改重新写。审核通过后就进入下一个节点，人力资源部门审核，当然人力资源也可以驳回请求，或者要你重新整改，人力资源审核通过之后就可以休假了，这个时候还可以选择是否发送Email。 /** * 节点接口 * @author gh * */ public abstract class Node { private static String name; //当前节点名称 //节点跳转 public abstract void nodeHandle(FlowContext context); public String getName() { return name; } public void setName(String name) { this.name = name; } } 相当于State类，这里维护一个节点名称。 /** * 领导节点 * * @author gh * */ public class LeadNode extends Node { @Override public void nodeHandle(FlowContext context) { //根据当前流程的状态，来控制流程的走向 //先判断流程是否结束 if(!context.isFlag()){ System.out.println(context.getMessage()); //先读取申请的内容 if(context!=null&&3==context.getStatus()){ //只有出于已经申请的状态才又部门领导审核 //设置当前节点的名称 setName(\"张经理\"); //加上审核意见 context.setMessage(context.getMessage()+getName()+\"审核通过;\"); //审核通过 context.setStatus(0); //审核通过并指向下一个节点 context.setNode(new HrNode()); context.getNode().nodeHandle(context); } }else{ System.err.println(\"流程已经结束\"); } } } 这里创建了一个领导节点，用来维护领导审核的流程，审核通过会交给HR审核； public class HrNode extends Node { @Override public void nodeHandle(FlowContext context) { //先判断流程是否结束 if(!context.isFlag()){ // 根据当前流程的状态，来控制流程的走向 if (context != null && 0 == context.getStatus()) { //只有上一级审核通过后才能轮到HR审核 // 设置当前节点的名称 setName(\"HR李\"); //读取上一级的审核内容并加上自己的意见 System.out.println(context.getMessage()+getName()+\"审核通过\"); // 审核通过 context.setStatus(0); //HR审核通过并指向下一个节点 ,如果没有下一个节点就把状态设置为终结 context.setFlag(true); } }else{ System.out.println(\"流程已经结束\"); } } } 这里HR审核通过并把节点设置为完结状态； /** * 流程控制 * * @author gh * */ public class FlowContext { private boolean flag; // 代表流程是否结束 /** * 流程状态 0：通过 1:驳回 2.退回整改 3.已申请 * */ private int status; private String message; // 消息 private Node node; // 节点信息 public boolean isFlag() { return flag; } public void setFlag(boolean flag) { this.flag = flag; } public int getStatus() { return status; } public void setStatus(int status) { this.status = status; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public Node getNode() { return node; } public void setNode(Node node) { this.node = node; } public static boolean start(FlowContext context) { Node node = new LeadNode(); context.setNode(node); // 设置初始节点 context.setStatus(3); // 设置状态为申请中 context.getNode().nodeHandle(context); // 发起请求 // 最后要知道是否申请成功 //判断当前是最后一个节点并且审核通过，而且流程结束 if(\"HR李\".equals(node.getName())&&0==context.getStatus()&&context.isFlag()){ System.out.println(\"审核通过,流程结束\"); return true; }else{ System.out.println(\"审核未通过，流程已经结束\"); return false; } } public FlowContext() { super(); } } 这里维护一个流程控制类，它会在HR和LEAD节点之后传递，并分别由他们去维护各自的节点。 最后写一个测试类测试一下： public static void main(String[] args) { FlowContext context=new FlowContext(); context.setMessage(\"本人王小二，因为十一家里有事情，所以要多请三天假，希望公司能够审核通过\"); context.start(context); } 打印结果如下 本人王小二，因为十一家里有事情，所以要多请三天假，希望公司能够审核通过 本人王小二，因为十一家里有事情，所以要多请三天假，希望公司能够审核通过张经理审核通过;HR李审核通过 审核通过,流程结束； 上面这个例子只是很简单的模仿了一下工作流控制状态的跳转。状态模式最主要的好处就是把状态的判断与控制放到了其服务端的内部，使得客户端不需要去写很多代码判断，来控制自己的节点跳转，而且这样实现的话，我们可以把每个节点都分开来处理，当流程流转到某个节点的时候，可以去写自己的节点流转方法。当然状态模式的缺点也很多，比如类的耦合度比较高，基本上三个类要同时去写，而且会创建很多的节点类。 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"140_策略模式_鸭子问题.html":{"url":"140_策略模式_鸭子问题.html","title":"鸭子问题","keywords":"","body":" new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-10 21:48:18 "},"141_策略模式_工作原理.html":{"url":"141_策略模式_工作原理.html","title":"工作原理","keywords":"","body":" new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 17:27:51 "},"142_策略模式_代码实践.html":{"url":"142_策略模式_代码实践.html","title":"代码实践","keywords":"","body":" new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 17:27:51 "},"143_策略模式_源码分析.html":{"url":"143_策略模式_源码分析.html","title":"源码分析","keywords":"","body":" new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-08 17:27:51 "},"144_策略模式_内容梳理.html":{"url":"144_策略模式_内容梳理.html","title":"内容梳理","keywords":"","body":"什么是策略模式1. Context上下文2. 策略角色3. 具体策略角色4. Client客户端二、策略模式的应用1. 何时使用2. 方法3. 优点4. 缺点5. 使用场景6. 应用实例7. 注意事项三、策略模式的实现什么是策略模式 策略这个词应该怎么理解，打个比方说，我们出门的时候会选择不同的出行方式，比如骑自行车、坐公交、坐火车、坐飞机、坐火箭等等，这些出行方式，每一种都是一个策略。 再比如我们去逛商场，商场现在正在搞活动，有打折的、有满减的、有返利的等等，其实不管商场如何进行促销，说到底都是一些算法，这些算法本身只是一种策略，并且这些算法是随时都可能互相替换的，比如针对同一件商品，今天打八折、明天满100减30，这些策略间是可以互换的。 策略模式（Strategy），定义了一组算法，将每个算法都封装起来，并且使它们之间可以互换。UML结构图如下： 其中，Context是上下文，用一个ConcreteStrategy来配置，维护一个对Strategy对象的引用；Strategy是策略类，用于定义所有支持算法的公共接口；ConcreteStrategy是具体策略类，封装了具体的算法或行为，继承于Strategy。 1. Context上下文 　　Context上下文角色，也叫Context封装角色，起承上启下的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。 public class Context { Strategy strategy; public Context(Strategy strategy) { this.strategy = strategy; } //上下文接口 public void contextInterface() { strategy.algorithmInterface(); } } 2. 策略角色 　　抽象策略角色，是对策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。algorithm是“运算法则”的意思。 public abstract class Strategy { //算法方法 public abstract void algorithmInterface(); } 3. 具体策略角色 　　用于实现抽象策略中的操作，即实现具体的算法，下方用print代替。测试类共3个ConcreteStrategy，其它两个类与ConcreteStrategyA同理，就不再赘述了。 public class ConcreteStrategyA extends Strategy { @Override public void algorithmInterface() { System.out.println(\"算法A实现\"); } } 4. Client客户端 　　下面依次更换策略，测试一下策略模式。 public class Client { public static void main(String[] args) { Context context; context = new Context(new ConcreteStrategyA()); context.contextInterface(); context = new Context(new ConcreteStrategyB()); context.contextInterface(); context = new Context(new ConcreteStrategyC()); context.contextInterface(); } } 运行结果如下： 二、策略模式的应用 1. 何时使用 一个系统有许多类，而区分它们的只是他们直接的行为时 2. 方法 将这些算法封装成一个一个的类，任意的替换 3. 优点 算法可以自由切换 避免使用多重条件判断（如果不用策略模式我们可能会使用多重条件语句，不利于维护） 扩展性良好，增加一个策略只需实现接口即可 4. 缺点 策略类数量会增多，每个策略都是一个类，复用的可能性很小 所有的策略类都需要对外暴露 5. 使用场景 多个类只有算法或行为上稍有不同的场景 算法需要自由切换的场景 需要屏蔽算法规则的场景 6. 应用实例 出行方式，自行车、汽车等，每一种出行方式都是一个策略 商场促销方式，打折、满减等 Java AWT中的LayoutManager，即布局管理器 7. 注意事项 如果一个系统的策略多于四个，就需要考虑使用混合模式来解决策略类膨胀的问题 三、策略模式的实现 　　下面就以商场促销为例使用策略模式实现商场促销算法。UML图如下： 　　1.上下文类 　　首先声明一个CashSuper对象，通过构造方法，传入具体的收费策略，getResult()方法的功能为根据收费策略的不同获得计算结果。 1 public class CashContext { 2 3 private CashSuper cashSuper; 4 5 public CashContext(CashSuper cashSuper) { 6 this.cashSuper = cashSuper; 7 } 8 9 public double getResult(double money) { 10 return cashSuper.acceptCash(money); 11 } 12 13 } 　　2. 现金收费抽象类 　　策略类，为抽象类，抽象出收费的方法供子类实现。 1 public abstract class CashSuper { 2 3 public abstract double acceptCash(double money); 4 5 } 　　3. 正常收费子类 　　没有任何活动的情况，正常收费，返回原价。 1 public class CashNormal extends CashSuper { 2 3 @Override 4 public double acceptCash(double money) { 5 return money; 6 } 7 8 } 　　4. 打折收费子类 　　打折活动，根据折扣返回打折后的价格。 1 public class CashRebate extends CashSuper { 2 3 private double moneyRebate = 1; //折扣 4 5 public CashRebate(double moneyRebate) { 6 this.moneyRebate = moneyRebate; 7 } 8 9 @Override 10 public double acceptCash(double money) { 11 return money * moneyRebate; 12 } 13 14 } 　　5. 返利收费子类 　　返利活动，输入返利条件和返利值，比如满300返100，moneyCoditation为300，moneyReturn为100。 　　 result = money - Math.floor(money / moneyConditation) * moneyReturn; 的意思为，如果当前金额大于等于返利条件，则使用当前金额减去返利值。 1 public class CashReturn extends CashSuper { 2 3 private double moneyConditation = 0.0; //返利条件 4 private double moneyReturn = 0.0d; //返利值 5 6 public CashReturn(double moneyConditation, double moneyReturn) { 7 this.moneyConditation = moneyConditation; 8 this.moneyReturn = moneyReturn; 9 } 10 11 @Override 12 public double acceptCash(double money) { 13 double result = money; 14 15 if (money >= moneyConditation) { 16 result = money - Math.floor(money / moneyConditation) * moneyReturn; 17 } 18 19 return result; 20 } 21 22 } 　　6. Client客户端 　　下面写一个简单的程序测试一下上方编写的代码。 1 public class Client { 2 3 public static void main(String[] args) { 4 CashContext cashContext = null; 5 6 Scanner scanner = new Scanner(System.in); 7 System.out.print(\"请输入打折方式（1/2/3）：\"); 8 int in = scanner.nextInt(); 9 String type = \"\"; 10 11 switch (in) { 12 case 1: 13 cashContext = new CashContext(new CashNormal()); 14 type += \"正常收费\"; 15 break; 16 17 case 2: 18 cashContext = new CashContext(new CashReturn(300, 100)); 19 type += \"满300返100\"; 20 break; 21 22 case 3: 23 cashContext = new CashContext(new CashRebate(0.8)); 24 type += \"打8折\"; 25 break; 26 27 default: 28 System.out.println(\"请输入1/2/3\"); 29 break; 30 } 31 32 double totalPrices = 0; 33 34 System.out.print(\"请输入单价：\"); 35 double price = scanner.nextDouble(); 36 System.out.print(\"请输入数量：\"); 37 double num = scanner.nextDouble(); 38 totalPrices = cashContext.getResult(price * num); 39 40 System.out.println(\"单价：\" + price + \"，数量：\" + num + \"，类型：\" + type + \"，合计：\" + totalPrices); 41 42 scanner.close(); 43 } 44 45 } 正常收费结果如下： 返利收费结果如下： 打折收费结果如下： 源码地址：GoF new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"145_职责链模式_采购审批.html":{"url":"145_职责链模式_采购审批.html","title":"采购审批","keywords":"","body":" 先看需求 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"146_职责链模式_工作原理.html":{"url":"146_职责链模式_工作原理.html","title":"工作原理","keywords":"","body":" new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"147_职责链模式_代码实践.html":{"url":"147_职责链模式_代码实践.html","title":"代码实践","keywords":"","body":" 这样不行 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"148_职责链模式_源码分析.html":{"url":"148_职责链模式_源码分析.html","title":"源码分析","keywords":"","body":"Spring源码分析 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "},"149_职责链模式_内容梳理.html":{"url":"149_职责链模式_内容梳理.html","title":"内容梳理","keywords":"","body":"职责链模式的注意事项和细节 将请求和处理分开,实现解耦,提高系统的灵活性 简化了对象,使对象不需要知道链的结构 性能会收到影响,特别是在链比较长的时间,因此需控制链中最大节点数量,一般通过Handler中设置一个最大节点数量,在setNext()方法中判断是否已经超过阈值,超过则不允许该链建立,避免出现超长链无意识地破坏系统性能. 一、什么是职责链模式 　　从文字角度出发，我们可以先将关注点放在“链”字上，很容易联想到链式结构，举个生活中常见的例子，击鼓传花游戏就是一个很典型的链式结构，所有人形成一条链，相互传递。而从另一个角度说，职责链就是所谓的多级结构，比如去医院开具病假条，普通医生只能开一天的证明，如果需要更多时常，则需将开具职责转交到上级去，上级医师只能开三天证明，如需更多时常，则需将职责转交到他的上级，以此类推，这就是一个职责链模式的典型应用。再比如公司请假，根据请假时常的不同，需要递交到的级别也不同，这种层级递进的关系就是一种多级结构。 　　职责链模式（Chain Of Responsibility），使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。UML结构图如下： 　　其中，Handler是抽象处理者，定义了一个处理请求的接口；ConcreteHandler是具体处理者，处理它所负责的请求，可访问它的后继者，如果可处理该请求就处理，否则就将该请求转发给它的后继者。 　　1. 抽象处理者 　　抽象处理者实现了三个职责： 定义一个请求的处理方法handlerMessage()，是唯一对外开放的方法 定义一个链的编排方式setNext()，用于设置下一个处理者 定义了具体的请求者必须实现的两个方法，即定义自己能够处理的级别的getHandlerLevel()方法及具体的处理任务echo()方法 1 public abstract class Handler { 2 3 private Handler nextHandler; //下一个处理者 4 5 public final Response handlerMessage(Request request) { 6 Response response = null; 7 8 if(this.getHandlerLevel().equals(request.getRequestLevel())) { //判断是否是自己的处理级别 9 response = this.echo(request); 10 } else { 11 if(this.nextHandler != null) { //下一处理者不为空 12 response = this.nextHandler.handlerMessage(request); 13 } else { 14 //没有适当的处理者，业务自行处理 15 } 16 } 17 18 return response; 19 } 20 21 //设定下一个处理者 22 public void setNext(Handler handler) { 23 this.nextHandler = handler; 24 } 25 26 //每个处理者的处理等级 27 protected abstract Level getHandlerLevel(); 28 29 //每个处理者都必须实现的处理任务 30 protected abstract Response echo(Request request); 31 32 } 　　2. 具体处理者 　　这里我们定义三个具体处理者，以便能组成一条链，ConcreteHandlerB及ConcreteHandlerC就不再赘述了。 1 public class ConcreteHandlerA extends Handler { 2 3 @Override 4 protected Level getHandlerLevel() { 5 //设置自己的处理级别 6 return null; 7 } 8 9 @Override 10 protected Response echo(Request request) { 11 //完成处理逻辑 12 return null; 13 } 14 15 } 　　3. Level类 　　Level类负责定义请求和处理级别，具体内容需根据业务产生。 1 public class Level { 2 //定义一个请求和处理等级 3 } 　　4. Request类 　　Request类负责封装请求，具体内容需根据业务产生。 1 public class Request { 2 3 //请求的等级 4 public Level getRequestLevel() { 5 return null; 6 } 7 8 } 　　5. Response类 　　Response类负责封装链中返回的结果，具体内容需根据业务产生。 1 public class Response { 2 //处理者返回的数据 3 } 　　6. Client客户端 　　我们在场景类或高层模块中对类进行组装，并传递请求，返回结果。如下对三个具体处理者进行组装，按照1→2→3的顺序，并得出返回结果。 1 public class Client { 2 3 public static void main(String[] args) { 4 Handler handler1 = new ConcreteHandlerA(); 5 Handler handler2 = new ConcreteHandlerB(); 6 Handler handler3 = new ConcreteHandlerC(); 7 8 //设置链中的阶段顺序 1->2->3 9 handler1.setNext(handler2); 10 handler2.setNext(handler3); 11 12 //提交请求返回结果 13 Response response = handler1.handlerMessage(new Request()); 14 } 15 16 } 　　当然这是个未完成的模板，最终结果会因为 request.getRequestLevel() 为空而抛出异常，具体内容需根据业务逻辑进行编写。 二、职责链模式的应用 　　1. 何时使用 处理消息时 　　2. 方法 拦截的类都实现同一接口 　　3. 优点 将请求和处理分开，实现解耦，提高系统的灵活性 简化了对象，使对象不需要知道链的结构 　　4. 缺点 性能会收到影响，特别是在链比较长的时候 调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂 不能保证请求一定被接收 　　5. 使用场景 有多个对象可以处理同一个请求 在不明确指定接收者的情况下，向多个对象中的提交请求 可动态指定一组对象处理请求 　　6. 应用实例 多级请求 击鼓传花 请假/加薪请求 Java Web中Tomcat对Encoding的处理、拦截器 　　7. 注意事项 需控制链中最大节点数量，一般通过在Handler中设置一个最大节点数量，在setNext()方法中判断是否已经超过阀值，超过则不允许该链建立，避免出现超长链无意识地破坏系统性能 三、职责链模式的实现 　　我们就以请假/加薪为例，实现一个较为简单的职责链模式。UML图如下： 　　1. 抽象管理者 　　通过Manager抽象类管理所有管理者，setSuperior()方法用于定义职责链的下一级，即定义当前管理者的上级。 1 public abstract class Manager { 2 3 protected String name; 4 protected Manager superior; //管理者的上级 5 6 public Manager(String name) { 7 this.name = name; 8 } 9 10 //设置管理者的上级 11 public void setSuperior(Manager superior) { 12 this.superior = superior; 13 } 14 15 //申请请求 16 public abstract void handlerRequest(Request request); 17 18 } 　　2. 具体管理者 　　经理类如下，只可批准两天以内的假期，其余请求将继续申请上级。 1 public class CommonManager extends Manager { 2 3 public CommonManager(String name) { 4 super(name); 5 } 6 7 @Override 8 public void handlerRequest(Request request) { 9 if (request.getRequestType().equals(\"请假\") && request.getNumber() 　　总监类如下，只可批准五天以内的假期，其余请求将继续申请上级。 1 public class Majordomo extends Manager { 2 3 public Majordomo(String name) { 4 super(name); 5 } 6 7 @Override 8 public void handlerRequest(Request request) { 9 if (request.getRequestType().equals(\"请假\") && request.getNumber() 　　总经理类，可以批准任意时常的假期，并且可以批准是否加薪。 1 public class GeneralManager extends Manager { 2 3 public GeneralManager(String name) { 4 super(name); 5 } 6 7 @Override 8 public void handlerRequest(Request request) { 9 if (request.getRequestType().equals(\"请假\")) { //能批准任意时长的假期 10 System.out.println(name + \":\" + request.getRequestContent() + \"，时长：\" + request.getNumber() + \"天，被批准\"); 11 } else if (request.getRequestType().equals(\"加薪\") && request.getNumber() 500) { 14 System.out.println(name + \":\" + request.getRequestContent() + \"，金额：￥\" + request.getNumber() + \"，再说吧\"); 15 } 16 } 17 18 } 　　3. 申请类 1 public class Request { 2 3 private String requestType; //申请类别 4 private String requestContent; //申请内容 5 private int number; //数量 6 7 public String getRequestType() { 8 return requestType; 9 } 10 11 public void setRequestType(String requestType) { 12 this.requestType = requestType; 13 } 14 15 public String getRequestContent() { 16 return requestContent; 17 } 18 19 public void setRequestContent(String requestContent) { 20 this.requestContent = requestContent; 21 } 22 23 public int getNumber() { 24 return number; 25 } 26 27 public void setNumber(int number) { 28 this.number = number; 29 } 30 31 } 　4. Client客户端 　　下面测试几组数据。 1 public class Client { 2 3 public static void main(String[] args) { 4 CommonManager commonManager = new CommonManager(\"尼古拉斯·经理\"); 5 Majordomo majordomo = new Majordomo(\"尼古拉斯·总监\"); 6 GeneralManager generalManager = new GeneralManager(\"尼古拉斯·总经理\"); 7 8 //设置上级 9 commonManager.setSuperior(majordomo); 10 majordomo.setSuperior(generalManager); 11 12 Request request = new Request(); 13 request.setRequestType(\"请假\"); 14 request.setRequestContent(\"adam请假\"); 15 request.setNumber(1); 16 commonManager.handlerRequest(request); 17 18 Request request2 = new Request(); 19 request2.setRequestType(\"请假\"); 20 request2.setRequestContent(\"adam请假\"); 21 request2.setNumber(4); 22 commonManager.handlerRequest(request2); 23 24 Request request3 = new Request(); 25 request3.setRequestType(\"加薪\"); 26 request3.setRequestContent(\"adam请求加薪\"); 27 request3.setNumber(500); 28 commonManager.handlerRequest(request3); 29 30 Request request4 = new Request(); 31 request4.setRequestType(\"加薪\"); 32 request4.setRequestContent(\"adam请求加薪\"); 33 request4.setNumber(1000); 34 commonManager.handlerRequest(request4); 35 } 36 37 } 　运行结果如下： 　　 　　源码地址：https://gitee.com/adamjiangwh/GoF new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-16 16:35:01 "}}